<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="张建宁的个人博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="张建宁的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>张建宁的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张建宁的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张建宁的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/" class="post-title-link" itemprop="url">JavaScript学习笔记（面向对象）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-10 10:10:57 / 修改时间：10:40:38" itemprop="dateCreated datePublished" datetime="2021-05-10T10:10:57+08:00">2021-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript学习笔记（面向对象和数组-）"><a href="#JavaScript学习笔记（面向对象和数组-）" class="headerlink" title="JavaScript学习笔记（面向对象和数组 ）"></a>JavaScript学习笔记（面向对象和数组 ）</h1><h2 id="1-面向对象简介"><a href="#1-面向对象简介" class="headerlink" title="1.面向对象简介"></a>1.面向对象简介</h2><p><strong>对象的作用是：封装信息</strong>。比如Student类里可以封装学生的姓名、年龄、成绩等。</p>
<p>对象具有<strong>特征</strong>（属性）和<strong>行为</strong>（方法）。</p>
<p>面向对象：可以创建自定义的类型，很好的支持继承和多态。</p>
<p>面向对象的特征：封装、继承、多态。</p>
<h2 id="2-对象简介"><a href="#2-对象简介" class="headerlink" title="2.对象简介"></a>2.对象简介</h2><h3 id="基本数据类型和引用数据类型的对比"><a href="#基本数据类型和引用数据类型的对比" class="headerlink" title="基本数据类型和引用数据类型的对比"></a>基本数据类型和引用数据类型的对比</h3><ul>
<li><strong>基本数据类型（值类型）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。</li>
<li><strong>引用数据类型（引用类型）</strong>：Object 对象。</li>
</ul>
<p><strong>基本数据类型</strong>：</p>
<p>基本数据类型的值直接保存在<strong>栈内存</strong>中，值与值之间是独立存在，修改一个变量不会影响其他的变量。</p>
<p><strong>对象</strong>：</p>
<p>只要不是那五种基本数据类型，就全都是对象。</p>
<p>如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。</p>
<p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。</p>
<p>对象是保存到<strong>堆内存</strong>中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间。变量保存的是对象的内存地址（对象的引用）。</p>
<p>换而言之，对象的值是保存在<strong>堆内存</strong>中的，而对象的引用（即变量）是保存在<strong>栈内存</strong>中的。</p>
<p><strong>如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响</strong>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &quot;孙悟空&quot;;</span><br><span class="line"></span><br><span class="line">var obj2 = obj;</span><br><span class="line"></span><br><span class="line">//修改obj的name属性</span><br><span class="line">obj.name = &quot;猪八戒&quot;;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，当我修改obj的name属性后，会发现，obj2的name属性也会被修改。因为obj和obj2指向的是堆内存中的同一个地址。</p>
<h2 id="3-对象的分类"><a href="#3-对象的分类" class="headerlink" title="3.对象的分类"></a>3.对象的分类</h2><p>1.内置对象：</p>
<ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>
<li>比如：Math、String、Number、Boolean、Function、Object….</li>
</ul>
<p>2.宿主对象：</p>
<ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。</li>
<li>比如 BOM DOM。比如<code>console</code>、<code>document</code>。</li>
</ul>
<p>3.自定义对象：</p>
<ul>
<li>由开发人员自己创建的对象</li>
</ul>
<h2 id="4-获取对象中的属性"><a href="#4-获取对象中的属性" class="headerlink" title="4.获取对象中的属性"></a>4.获取对象中的属性</h2><p><strong>方式1</strong>：</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.属性名</span><br></pre></td></tr></table></figure>

<p>如果获取对象中没有的属性，不会报错而是返回<code>undefined</code>。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">//向obj中添加一个name属性</span><br><span class="line">obj.name = &quot;孙悟空&quot;;</span><br><span class="line"></span><br><span class="line">//向obj中添加一个gender属性</span><br><span class="line">obj.gender = &quot;男&quot;;</span><br><span class="line"></span><br><span class="line">//向obj中添加一个age属性</span><br><span class="line">obj.age = 18;</span><br><span class="line"></span><br><span class="line">// 获取对象中的属性，并打印出来</span><br><span class="line">console.log(obj.gender); // 打印结果：男</span><br><span class="line">console.log(obj.color);  // 打印结果：undefined</span><br></pre></td></tr></table></figure>

<p><strong>方式2</strong>：可以使用<code>[]</code>这种形式去操作属性</p>
<p>对象的属性名不强制要求遵守标识符的规范，但是我们使用是还是尽量按照标识符的规范去做。</p>
<p>但如果要使用特殊的属性名，就不能采用<code>.</code>的方式来操作对象的属性。比如说，<code>123</code>这种属性名，如果我们直接写成<code>obj.123 = 789</code>，是会报错的。那怎么办呢？办法如下：</p>
<p>语法格式如下：（读取时，也是采用这种方式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象[&quot;属性名&quot;] = 属性值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这种语法格式，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[&quot;123&quot;] = 789;</span><br></pre></td></tr></table></figure>

<p><strong>重要</strong>：使用<code>[]</code>这种形式去操作属性，更加的灵活，因为，我们可以在<code>[]</code>中直接传递一个<strong>变量</strong>，这样变量值是多少就会读取那个属性。</p>
<h3 id="修改对象的属性值"><a href="#修改对象的属性值" class="headerlink" title="修改对象的属性值"></a>修改对象的属性值</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象.属性名 = 新值</span><br><span class="line">对象[属性名] = 新值</span><br><span class="line">obj.name = &quot;tom&quot;;</span><br><span class="line">obj[&#x27;name&#x27;] = &#x27;tom&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete obj.name;</span><br><span class="line">delete obj[&#x27;name&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="5-in-运算符"><a href="#5-in-运算符" class="headerlink" title="5. in 运算符"></a>5. in 运算符</h2><p>通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回true，没有则返回false。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;属性名&quot; in 对象</span><br><span class="line">对象.hasOwnProperty(&#x27;属性名&#x27;)</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//检查obj中是否含有name属性</span><br><span class="line">console.log(&quot;name&quot; in obj);</span><br><span class="line">console.log(obj.hasOwnProperty(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>

<p>我们平时使用的对象不一定是自己创建的，可能是别人提供的，这个时候，in 运算符可以派上用场。</p>
<h2 id="6-对象字面量"><a href="#6-对象字面量" class="headerlink" title="6. 对象字面量"></a>6. 对象字面量</h2><p>如果要创建一个对象，我们可以使用下面这种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br></pre></td></tr></table></figure>

<p>但是上面的这种方式，比较麻烦，我们还有更简洁的方式来创建一个对象。如下。</p>
<p>使用对象字面量来创建一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值….}</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = &#123;</span><br><span class="line"></span><br><span class="line">    name: &quot;猪八戒&quot;,</span><br><span class="line">    age: 13,</span><br><span class="line">    gender: &quot;男&quot;,</span><br><span class="line">    test: &#123;</span><br><span class="line">        name: &quot;沙僧&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    //我们还可以在对象中增加一个方法。以后可以通过obj2.sayName()的方式调用这个方法</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        console.log(&#x27;smyhvae&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。</p>
<p>属性名和属性值是一组一组的键值对结构，键和值之间使用<code>:</code>连接，多个值对之间使用<code>,</code>隔开。如果一个属性之后没有其他的属性了，就不要写<code>,</code>，因为它是对象的最后一个属性。</p>
<h2 id="7-遍历对象中的属性：for-in"><a href="#7-遍历对象中的属性：for-in" class="headerlink" title="7. 遍历对象中的属性：for in"></a>7. 遍历对象中的属性：for in</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var 变量 in 对象) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的<strong>每个属性的 属性名 赋值给变量</strong>。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var obj = &#123;</span><br><span class="line">            name: &quot;smyhvae&quot;,</span><br><span class="line">            age: 26,</span><br><span class="line">            gender: &quot;男&quot;,</span><br><span class="line">            address: &quot;shenzhen&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //枚举对象中的属性</span><br><span class="line">        for (var n in obj) &#123;</span><br><span class="line">            console.log(&quot;属性名:&quot; + n);</span><br><span class="line">            console.log(&quot;属性值:&quot; + obj[n]); // 注意，因为这里的属性名 n 是变量，所以，如果想获取属性值，不能写成 obj.n，而是要写成 obj[n]</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180314_2125.png" alt="img"></p>
<h2 id="8-栈内存和堆内存"><a href="#8-栈内存和堆内存" class="headerlink" title="8.栈内存和堆内存"></a>8.栈内存和堆内存</h2><p>我们首先记住一句话：JS中，所有的<strong>变量</strong>都是保存在<strong>栈内存</strong>中的。</p>
<p>然后来看看下面的区别。</p>
<p><strong>基本数据类型</strong>：</p>
<p>基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。</p>
<p><strong>引用数据类型</strong>：</p>
<p>对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而<strong>变量保存了对象的内存地址</strong>（对象的引用）。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。</p>
<h2 id="9-this"><a href="#9-this" class="headerlink" title="9. this"></a>9. this</h2><p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的 上下文对象。</p>
<p>根据函数的调用方式的不同，this会指向不同的对象：【重要】</p>
<ul>
<li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li>
<li>2.以方法的形式调用时，this是调用方法的那个对象</li>
<li>3.以构造函数的形式调用时，this是新创建的那个对象</li>
<li>4.使用call和apply调用时，this是指定的那个对象</li>
</ul>
<p><strong>针对第1条的举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &quot;smyh&quot;,</span><br><span class="line">    sayName: fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &quot;vae&quot;,</span><br><span class="line">    sayName: fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var name = &quot;全局的name属性&quot;;</span><br><span class="line"></span><br><span class="line">//以函数形式调用，this是window</span><br><span class="line">fun();       //可以理解成 window.fun()</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Window</span><br><span class="line">全局的name属性</span><br></pre></td></tr></table></figure>

<p>上面的举例可以看出，this指向的是window对象，所以 this.name 指的是全局的name。</p>
<p><strong>第2条的举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &quot;smyh&quot;,</span><br><span class="line">    sayName: fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &quot;vae&quot;,</span><br><span class="line">    sayName: fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var name = &quot;全局的name属性&quot;;</span><br><span class="line"></span><br><span class="line">//以方法的形式调用，this是调用方法的对象</span><br><span class="line">obj2.sayName();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">vae</span><br></pre></td></tr></table></figure>

<p>上面的举例可以看出，this指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。</p>
<p><strong>箭头函数中this的指向</strong>：</p>
<p>ES6中的箭头函数并不会使用上面四条标准的绑定规则，而是会继承外层函数调用的this绑定（无论this绑定到什么）。</p>
<h2 id="10-类数组-arguments"><a href="#10-类数组-arguments" class="headerlink" title="10.类数组 arguments"></a>10.类数组 arguments</h2><blockquote>
<p>这部分，小白可能看不懂。所以，这一段，暂时可以忽略。</p>
</blockquote>
<p>在调用函数时，浏览器每次都会传递进两个隐含的参数：</p>
<ul>
<li>1.函数的上下文对象 this</li>
<li>2.<strong>封装实参的对象</strong> arguments</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    console.log(typeof arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p><img src="http://img.smyhvae.com/20180315_0903.png" alt="img"></p>
<p>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。</p>
<p><strong>arguments代表的是实参</strong>。在调用函数时，我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments<strong>只在函数中使用</strong>。</p>
<h3 id="1、返回函数实参的个数：arguments-length"><a href="#1、返回函数实参的个数：arguments-length" class="headerlink" title="1、返回函数实参的个数：arguments.length"></a>1、返回函数<strong>实参</strong>的个数：arguments.length</h3><p>arguments.length可以用来获取<strong>实参的长度</strong>。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn(2,4);</span><br><span class="line">fn(2,4,6);</span><br><span class="line">fn(2,4,6,8);</span><br><span class="line"></span><br><span class="line">function fn(a,b) &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    console.log(fn.length);         //获取形参的个数</span><br><span class="line">    console.log(arguments.length);  //获取实参的个数</span><br><span class="line"></span><br><span class="line">    console.log(&quot;----------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180125_2140.png" alt="img"></p>
<p>我们即使不定义形参，也可以通过arguments来使用实参（只不过比较麻烦）：arguments[0] 表示第一个实参、arguments[1] 表示第二个实参…</p>
<h3 id="2、返回正在执行的函数：arguments-callee"><a href="#2、返回正在执行的函数：arguments-callee" class="headerlink" title="2、返回正在执行的函数：arguments.callee"></a>2、返回正在执行的函数：arguments.callee</h3><p>arguments里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.callee == fun); //打印结果为true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>在使用函数<strong>递归</strong>调用时，推荐使用arguments.callee代替函数名本身。</p>
<h3 id="3、arguments可以修改元素"><a href="#3、arguments可以修改元素" class="headerlink" title="3、arguments可以修改元素"></a>3、arguments可以修改元素</h3><p>之所以说arguments是伪数组，是因为：<strong>arguments可以修改元素，但不能改变数组的长短</strong>。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn(2,4);</span><br><span class="line">fn(2,4,6);</span><br><span class="line">fn(2,4,6,8);</span><br><span class="line"></span><br><span class="line">function fn(a,b) &#123;</span><br><span class="line">    arguments[0] = 99;  //将实参的第一个数改为99</span><br><span class="line">    arguments.push(8);  //此方法不通过，因为无法增加元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-创建自定义对象的几种方法"><a href="#11-创建自定义对象的几种方法" class="headerlink" title="11. 创建自定义对象的几种方法"></a>11. 创建自定义对象的几种方法</h2><h3 id="方式一：对象字面量"><a href="#方式一：对象字面量" class="headerlink" title="方式一：对象字面量"></a>方式一：对象字面量</h3><p><strong>对象的字面量</strong>就是一个{}。里面的属性和方法均是<strong>键值对</strong>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">            name: &quot;生命壹号&quot;,</span><br><span class="line">            age: 26,</span><br><span class="line">            isBoy: true,</span><br><span class="line">            sayHi: function() &#123;</span><br><span class="line">                console.log(this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">console.log(o);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p><img src="http://img.smyhvae.com/20180125_1834.png" alt="img"></p>
<h3 id="方式二：工厂模式"><a href="#方式二：工厂模式" class="headerlink" title="方式二：工厂模式"></a>方式二：工厂模式</h3><p>通过该方法可以大批量的创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 使用工厂方法创建对象</span><br><span class="line"> *  通过该方法可以大批量的创建对象</span><br><span class="line"> */</span><br><span class="line">function createPerson(name, age, gender) &#123;</span><br><span class="line">    //创建一个新的对象</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    //向对象中添加属性</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.gender = gender;</span><br><span class="line">    obj.sayName = function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    //将新的对象返回</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = createPerson(&quot;猪八戒&quot;, 28, &quot;男&quot;);</span><br><span class="line">var obj3 = createPerson(&quot;白骨精&quot;, 16, &quot;女&quot;);</span><br><span class="line">var obj4 = createPerson(&quot;蜘蛛精&quot;, 18, &quot;女&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>弊端：</strong></p>
<p>使用工厂方法创建的对象，使用的构造函数都是Object。<strong>所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象</strong>。</p>
<h3 id="方式三：利用构造函数"><a href="#方式三：利用构造函数" class="headerlink" title="方式三：利用构造函数"></a>方式三：利用构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//利用构造函数自定义对象</span><br><span class="line">var stu1 = new Student(&quot;smyh&quot;);</span><br><span class="line">console.log(stu1);</span><br><span class="line">stu1.sayHi();</span><br><span class="line"></span><br><span class="line">var stu2 = new Student(&quot;vae&quot;);</span><br><span class="line">console.log(stu2);</span><br><span class="line">stu2.sayHi();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个构造函数</span><br><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;    //this指的是构造函数中的对象实例</span><br><span class="line">    this.sayHi = function () &#123;</span><br><span class="line">        console.log(this.name + &quot;厉害了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180125_1350.png" alt="img"></p>
<p>接下来，我们专门来讲一下构造函数。</p>
<h2 id="12-构造函数"><a href="#12-构造函数" class="headerlink" title="12. 构造函数"></a>12. 构造函数</h2><h3 id="代码引入"><a href="#代码引入" class="headerlink" title="代码引入"></a>代码引入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个构造函数，专门用来创建Person对象</span><br><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">  this.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个构造函数，专门用来创建 Dog 对象</span><br><span class="line">function Dog() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var per = new Person(&quot;孙悟空&quot;, 18, &quot;男&quot;);</span><br><span class="line">var per2 = new Person(&quot;玉兔精&quot;, 16, &quot;女&quot;);</span><br><span class="line">var per3 = new Person(&quot;奔波霸&quot;, 38, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">var dog = new Dog();</span><br></pre></td></tr></table></figure>

<h3 id="构造函数和普通函数的区别"><a href="#构造函数和普通函数的区别" class="headerlink" title="构造函数和普通函数的区别"></a>构造函数和普通函数的区别</h3><p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。</p>
<p>构造函数和普通函数的区别就是<strong>调用方式</strong>的不同：普通函数是直接调用，而构造函数需要使用new关键字来调用。</p>
<p><strong>this的指向也有所不同</strong>：</p>
<ul>
<li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li>
<li>2.以方法的形式调用时，this是调用方法的那个对象</li>
<li>3.以构造函数的形式调用时，this是新创建的那个对象</li>
</ul>
<h3 id="new-一个构造函数的执行流程"><a href="#new-一个构造函数的执行流程" class="headerlink" title="new 一个构造函数的执行流程"></a>new 一个构造函数的执行流程</h3><p>（1）开辟内存空间，存储新创建的对象</p>
<p>（2）将新建的对象设置为构造函数中的this，在构造函数中可以使用this来引用 新建的对象</p>
<p>（3）执行函数中的代码（包括设置对象属性和方法等）</p>
<p>（4）将新建的对象作为返回值返回</p>
<p>因为this指的是new一个Object之后的对象实例。于是，下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个函数</span><br><span class="line">function createStudent(name) &#123;</span><br><span class="line">    var student = new Object();</span><br><span class="line">    student.name = name;      //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改进为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个函数</span><br><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;       //this指的是构造函数中的对象实例</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意上方代码中的注释。</p>
<h3 id="类、实例"><a href="#类、实例" class="headerlink" title="类、实例"></a>类、实例</h3><p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个<strong>类</strong>。</p>
<p>通过一个构造函数创建的对象，称为该类的<strong>实例</strong>。</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用 instanceof 可以检查<strong>一个对象是否为一个类的实例</strong>。</p>
<p><strong>语法如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 instanceof 构造函数</span><br></pre></td></tr></table></figure>

<p>如果是，则返回true；否则返回false。</p>
<p><strong>代码举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Dog() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line"></span><br><span class="line">var dog1 = new Dog();</span><br><span class="line"></span><br><span class="line">console.log(person1 instanceof Person); // 打印结果： true</span><br><span class="line">console.log(dog1 instanceof Person); // 打印结果：false</span><br><span class="line"></span><br><span class="line">console.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true</span><br></pre></td></tr></table></figure>

<p>根据上方代码中的最后一行，需要补充一点：<strong>所有的对象都是Object的后代，因此 <code>任何对象 instanceof Object</code> 的返回结果都是true</strong>。</p>
<h2 id="13-others"><a href="#13-others" class="headerlink" title="13. others"></a>13. others</h2><h3 id="json的介绍"><a href="#json的介绍" class="headerlink" title="json的介绍"></a>json的介绍</h3><blockquote>
<p>对象字面量和json比较像，这里我们对json做一个简单介绍。</p>
</blockquote>
<p>JSON：JavaScript Object Notation（JavaScript对象表示形式）。</p>
<p>JSON和对象字面量的区别：JSON的属性必须用双引号引号引起来，对象字面量可以省略。</p>
<p>json举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;name&quot; : &quot;zs&quot;,</span><br><span class="line">      &quot;age&quot; : 18,</span><br><span class="line">      &quot;sex&quot; : true,</span><br><span class="line">      &quot;sayHi&quot; : function() &#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>注：json里一般放常量、数组、对象等，但很少放function。</p>
<p>另外，对象和json没有长度，json.length的打印结果是undefined。于是乎，自然也就不能用for循环遍历（因为遍历时需要获取长度length）。</p>
<p><strong>json遍历的方法：</strong></p>
<p>json 采用 <code>for...in...</code>进行遍历，和数组的遍历方式不同。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var myJson = &#123;</span><br><span class="line">        &quot;name&quot;: &quot;smyhvae&quot;,</span><br><span class="line">        &quot;aaa&quot;: 111,</span><br><span class="line">        &quot;bbb&quot;: 222</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //json遍历的方法：for...in...</span><br><span class="line">    for (var key in myJson) &#123;</span><br><span class="line">        console.log(key);   //获取 键</span><br><span class="line">        console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）</span><br><span class="line">        console.log(&quot;------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180203_1518.png" alt="img"></p>
<h2 id="14-原型"><a href="#14-原型" class="headerlink" title="14. 原型"></a>14. 原型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    this.age = age;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">    //向对象中添加一个方法</span><br><span class="line">    this.sayName = function () &#123;</span><br><span class="line">        console.log(&quot;我是&quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个Person的实例</span><br><span class="line">var per = new Person(&quot;孙悟空&quot;, 18, &quot;男&quot;);</span><br><span class="line">var per2 = new Person(&quot;猪八戒&quot;, 28, &quot;男&quot;);</span><br><span class="line">per.sayName();</span><br><span class="line">per2.sayName();</span><br><span class="line"></span><br><span class="line">console.log(per.sayName == per2.sayName);  //打印结果为false</span><br></pre></td></tr></table></figure>

<p><strong>分析如下</strong>：</p>
<p>上方代码中，我们的sayName方法是写在构造函数 Person 内部的，然后在两个实例中进行了调用。造成的结果是，<strong>构造函数每执行一次，就会给每个实例创建一个新的 sayName 方法</strong>。也就是说，每个实例的sayName都是唯一的。因此，最后一行代码的打印结果为false。</p>
<p>按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？</p>
<p>还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">    //向对象中添加一个方法</span><br><span class="line">    this.sayName = fun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将sayName方法在全局作用域中定义</span><br><span class="line">/*</span><br><span class="line"> * 将函数定义在全局作用域，污染了全局作用域的命名空间</span><br><span class="line"> *  而且定义在全局作用域中也很不安全</span><br><span class="line"> */</span><br><span class="line">function fun() &#123;</span><br><span class="line">    alert(&quot;Hello大家好，我是:&quot; + this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比较好的方式是，在原型中添加sayName方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(&quot;Hello大家好，我是:&quot;+this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这也就引入了我们本文要讲的「原型」。</p>
<h3 id="原型prototype的概念"><a href="#原型prototype的概念" class="headerlink" title="原型prototype的概念"></a>原型prototype的概念</h3><p><strong>认识1</strong>：</p>
<p>我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。</p>
<p>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义构造函数</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var per1 = new Person();</span><br><span class="line">var per2 = new Person();</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype); // 打印结果：[object object]</span><br><span class="line"></span><br><span class="line">console.log(per1.__proto__ == Person.prototype); // 打印结果：true</span><br></pre></td></tr></table></figure>

<p>上方代码的最后一行：打印结果表明，<code>实例.__proto__</code> 和 <code>构造函数.prototype</code>都指的是原型对象。</p>
<p><strong>认识2</strong>：</p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<p>以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。</p>
<p><strong>认识3</strong>：</p>
<p>使用 <code>in</code> 检查对象中是否含有某个属性时，如果对象中没有但是<strong>原型中</strong>有，也会返回true。</p>
<p>可以使用对象的<code>hasOwnProperty()</code>来检查<strong>对象自身中</strong>是否含有该属性。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：</p>
<ul>
<li>它会先在对象自身中寻找，如果有则直接使用；</li>
<li>如果没有则会去原型对象中寻找，如果找到则直接使用；</li>
<li>如果没有则去原型的原型中寻找，直到找到Object对象的原型。</li>
<li>Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一次接触「原型」和「原型链」的时候，会比较难理解。多接触几次，再回过头来看，就慢慢熟悉了。</p>
<h2 id="15-对象的-toString-方法"><a href="#15-对象的-toString-方法" class="headerlink" title="15. 对象的 toString() 方法"></a>15. 对象的 toString() 方法</h2><p>我们先来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var per1 = new Person(&quot;vae&quot;, 26, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;per1 = &quot; + per1);</span><br><span class="line">console.log(&quot;per1 = &quot; + per1.toString());</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">per1 = [object Object]</span><br><span class="line">per1 = [object Object]</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们尝试打印实例 per1 的内部信息，但是发现，无论是打印 <code>per1</code> 还是打印 <code>per1.toString()</code>，结果都是<code>object</code>，这是为啥呢？分析如下：</p>
<ul>
<li>当我们直接在页面中打印一个对象时，其实是输出了对象的toString()方法的返回值。</li>
<li>如果我们希望在打印对象时，不输出[object Object]，可以手动为对象添加一个toString()方法。意思是，重写 toString() 方法。</li>
</ul>
<p>重写 toString() 方法，具体做法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式一：重写 Person 原型的toString方法。针对 Person 的所有实例生效</span><br><span class="line">Person.prototype.toString = function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &quot;Person[name=&quot; +</span><br><span class="line">      this.name +</span><br><span class="line">      &quot;,age=&quot; +</span><br><span class="line">      this.age +</span><br><span class="line">      &quot;,gender=&quot; +</span><br><span class="line">      this.gender +</span><br><span class="line">      &quot;]&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 方式二：仅重写实例 per1 的 toString方法。但是这种写法，只对 per1 生效， 对 per2 无效</span><br><span class="line">/*</span><br><span class="line">per1.toString = function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &quot;Person[name=&quot; +</span><br><span class="line">      this.name +</span><br><span class="line">      &quot;,age=&quot; +</span><br><span class="line">      this.age +</span><br><span class="line">      &quot;,gender=&quot; +</span><br><span class="line">      this.gender +</span><br><span class="line">      &quot;]&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var per1 = new Person(&quot;smyh&quot;, 26, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">var per2 = new Person(&quot;vae&quot;, 30, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;per1 = &quot; + per1);</span><br><span class="line">console.log(&quot;per2 = &quot; + per2.toString());</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">per1 = Person[name=smyh,age=26,gender=男]</span><br><span class="line">per2 = Person[name=vae,age=30,gender=男]</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>上面的代码中，仔细看注释。我们重写了 Person 原型的 toString()，这样的话，可以保证对 Person 的所有实例生效。</p>
<p>从这个例子，我们可以看出 <code>prototype</code> 的作用。</p>
<h2 id="16-数组简介"><a href="#16-数组简介" class="headerlink" title="16. 数组简介"></a>16. 数组简介</h2><p>数组（Array）是属于<strong>内置对象</strong>，我们可以在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">MDN</a>网站上查询各种方法。</p>
<p>数组和普通对象的功能类似，也是用来存储一些值的。不同的是：</p>
<ul>
<li>普通对象是使用字符串作为属性名的，而数组是使用数字来作为<strong>索引</strong>来操作元素。索引：从0开始的整数就是索引。</li>
</ul>
<p>数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。</p>
<h2 id="17-数组的基本操作"><a href="#17-数组的基本操作" class="headerlink" title="17. 数组的基本操作"></a>17. 数组的基本操作</h2><p>数组的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组。</p>
<p>数组的元素中，如果存放的是数组，我们就称这种数组为二维数组。</p>
<h3 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h3><p><strong>方式一</strong>：字面量定义。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong>：对象定义（数组的构造函数）。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(参数);</span><br></pre></td></tr></table></figure>

<p>如果<strong>参数为空</strong>，则表示创建一个空数组；参数位置是<strong>一个数值</strong>时，表示数组长度；参数位置是<strong>多个数值</strong>时，表示数组中的元素。</p>
<p>上面的两种方式，我来举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">var arr1 = [11, 12, 13];</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">var arr2 = new Array(); // 参数为空</span><br><span class="line">var arr3 = new Array(4); // 参数为一个数值</span><br><span class="line">var arr4 = new Array(15, 16, 17); // 参数为多个数值</span><br><span class="line"></span><br><span class="line">console.log(typeof arr1);  // 打印结果：object</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr1 = &quot; + JSON.stringify(arr1));</span><br><span class="line">console.log(&quot;arr2 = &quot; + JSON.stringify(arr2));</span><br><span class="line">console.log(&quot;arr3 = &quot; + JSON.stringify(arr3));</span><br><span class="line">console.log(&quot;arr4 = &quot; + JSON.stringify(arr4));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line"></span><br><span class="line">arr1 = [11,12,13]</span><br><span class="line">arr2 = []</span><br><span class="line">arr3 = [null,null,null,null]</span><br><span class="line">arr4 = [15,16,17]</span><br></pre></td></tr></table></figure>

<p>从上方打印结果的第一行里，可以看出，数组的类型其实也是属于<strong>对象</strong>。</p>
<h3 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组[索引] = 值</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [];</span><br><span class="line"></span><br><span class="line">// 向数组中添加元素</span><br><span class="line">arr[0] = 10;</span><br><span class="line">arr[1] = 33;</span><br><span class="line">arr[2] = 22;</span><br><span class="line">arr[3] = 44;</span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的元素"><a href="#获取数组中的元素" class="headerlink" title="获取数组中的元素"></a>获取数组中的元素</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组[索引]</span><br></pre></td></tr></table></figure>

<p>数组的索引代表的是数组中的元素在数组中的位置，从0开始。</p>
<p>如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回undefined。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [21, 22, 23];</span><br><span class="line"></span><br><span class="line">console.log(arr[0]); // 打印结果：21</span><br><span class="line">console.log(arr[5]); // 打印结果：undefined</span><br></pre></td></tr></table></figure>

<h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>可以使用<code>length</code>属性来获取数组的长度(元素的个数)。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组的长度 = 数组名.length；</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [21, 22, 23];</span><br><span class="line"></span><br><span class="line">console.log(arr.length); // 打印结果：3</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>对于连续的数组，使用length可以获取到数组的长度（元素的个数）；对于非连续的数组，使用length会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组。</p>
<h3 id="修改数组的长度（修改length）"><a href="#修改数组的长度（修改length）" class="headerlink" title="修改数组的长度（修改length）"></a>修改数组的长度（修改length）</h3><ul>
<li>如果修改的length大于原长度，则多出部分会空出来，置为 null。</li>
<li>如果修改的length小于原长度，则多出的元素会被删除，数组将从后面删除元素。</li>
<li>（特例：伪数组arguments的长度可以修改，但是不能修改里面的元素，后面单独讲。）</li>
</ul>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [11, 12, 13];</span><br><span class="line">var arr2 = [21, 22, 23];</span><br><span class="line"></span><br><span class="line">// 修改数组 arr1 的 length</span><br><span class="line">arr1.length = 1;</span><br><span class="line">console.log(JSON.stringify(arr1));</span><br><span class="line"></span><br><span class="line">// 修改数组 arr2 的 length</span><br><span class="line">arr2.length = 5;</span><br><span class="line">console.log(JSON.stringify(arr2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[11]</span><br><span class="line"></span><br><span class="line">[21,22,23,null,null]</span><br></pre></td></tr></table></figure>

<h2 id="数组的常见方法以及数组的遍历"><a href="#数组的常见方法以及数组的遍历" class="headerlink" title="数组的常见方法以及数组的遍历"></a>数组的常见方法以及数组的遍历</h2><p><strong>数组的四个基本方法如下</strong>：（数组元素的添加和删除）</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">push()</td>
<td align="left">向数组的<strong>最后面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">pop()</td>
<td align="left">删除数组中的<strong>最后一个</strong>元素，返回结果为<strong>被删除的元素</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">unshift()</td>
<td align="left">在数组<strong>最前面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">shift()</td>
<td align="left">删除数组中的<strong>第一个</strong>元素，返回结果为<strong>被删除的元素</strong></td>
<td align="left">会改变原数组</td>
</tr>
</tbody></table>
<p><strong>数组的常见方法如下</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">slice()</td>
<td align="left">从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">splice()</td>
<td align="left">从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>删除的数组元素</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">concat()</td>
<td align="left">连接两个或多个数组，返回 结果为<strong>新的数组</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">join()</td>
<td align="left">将数组转换为字符串，返回结果为<strong>转换后的字符串</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">reverse()</td>
<td align="left">反转数组，返回结果为<strong>反转后的数组</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">sort()</td>
<td align="left">对数组的元素,默认按照<strong>Unicode编码</strong>，从小到大进行排序</td>
<td align="left">会改变原数组</td>
</tr>
</tbody></table>
<p><strong>遍历数组的方法如下</strong>：</p>
<ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for循环</td>
<td align="left">这个大家都懂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">forEach()</td>
<td align="left">和 for循环类似，但需要兼容IE8以上</td>
<td align="left">forEach() 没有返回值。也就是说，它的返回值是 undefined</td>
</tr>
<tr>
<td align="left">map()</td>
<td align="left">对原数组中的每一项进行加工，将组成新的数组</td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">filter()</td>
<td align="left">对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组，返回结果为<strong>新的数组</strong>。可以起到过滤的作用</td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">every()</td>
<td align="left">如果有一项返回false，则停止遍历，此方法返回 false</td>
<td align="left">一假即假。要求每一项都返回true，最终的结果才返回true</td>
</tr>
<tr>
<td align="left">some()</td>
<td align="left">只要有一项返回true，则停止遍历，此方法返回true</td>
<td align="left">一真即真。要求每一项都返回false，最终的结果才返回false</td>
</tr>
<tr>
<td align="left">reduce</td>
<td align="left">为数组中的每一个元素，依次执行回调函数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">for in</td>
<td align="left"></td>
<td align="left">例子：<code>for(var i in arr)&#123;console.log(arr[i],typeof i)&#125;</code></td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>数组的其他方法如下</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array.isArray()</td>
<td align="left">判断是否是数组，返回值是true或false</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">indexOf(value)</td>
<td align="left">从前往后索引，获取 value 在数组中的第一个下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lastIndexOf(value)</td>
<td align="left">从后往前索引，获取 value 在数组中的最后一个下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">find(function())</td>
<td align="left">找出<strong>第一个</strong>满足「指定条件返回true」的元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">findIndex(function())</td>
<td align="left">找出<strong>第一个</strong>满足「指定条件返回true」的元素的index</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Array.from(arrayLike)</td>
<td align="left">将<strong>伪数组</strong>转化为<strong>真数组</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Array.of(value1, value2, value3)</td>
<td align="left">将<strong>一系列值</strong>转换成数组。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="数组的四个基本方法（数组元素的添加和删除）"><a href="#数组的四个基本方法（数组元素的添加和删除）" class="headerlink" title="数组的四个基本方法（数组元素的添加和删除）"></a>数组的四个基本方法（数组元素的添加和删除）</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><p><code>push()</code>：向数组的<strong>最后面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组的新长度 = 数组.push(元素);</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.push(&quot;王四&quot;); // 末尾插入一个元素</span><br><span class="line">var result2 = arr.push(&quot;王五&quot;, &quot;王六&quot;); // 末尾插入多个元素</span><br><span class="line"></span><br><span class="line">console.log(result1); // 打印结果：4</span><br><span class="line">console.log(result2); // 打印结果：6</span><br><span class="line">console.log(JSON.stringify(arr)); // 打印结果：[&quot;王一&quot;,&quot;王二&quot;,&quot;王三&quot;,&quot;王四&quot;,&quot;王五&quot;,&quot;王六&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p><code>pop()</code>：删除数组中的<strong>最后一个</strong>元素，返回结果为<strong>被删除的元素</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被删除的元素 = 数组.pop();</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.pop();</span><br><span class="line"></span><br><span class="line">console.log(result1); // 打印结果：王三</span><br><span class="line">console.log(JSON.stringify(arr)); // 打印结果：[&quot;王一&quot;,&quot;王二&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p><code>unshift()</code>：在数组<strong>最前面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong>。插入元素后，其他元素的索引会依次调整。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组的新长度 = 数组.unshift(元素);</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.unshift(&quot;王四&quot;); // 最前面插入一个元素</span><br><span class="line">var result2 = arr.unshift(&quot;王五&quot;, &quot;王六&quot;); // 最前面插入多个元素</span><br><span class="line"></span><br><span class="line">console.log(result1); // 打印结果：4</span><br><span class="line">console.log(result2); // 打印结果：6</span><br><span class="line">console.log(JSON.stringify(arr)); // 打印结果：[&quot;王五&quot;,&quot;王六&quot;,&quot;王四&quot;,&quot;王一&quot;,&quot;王二&quot;,&quot;王三&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p><code>shift()</code>：删除数组中的<strong>第一个</strong>元素，返回结果为<strong>被删除的元素</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被删除的元素 = 数组.shift();</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.shift();</span><br><span class="line"></span><br><span class="line">console.log(result1); // 打印结果：王一</span><br><span class="line">console.log(JSON.stringify(arr)); // 打印结果：[&quot;王二&quot;,&quot;王三&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="数组的常见方法"><a href="#数组的常见方法" class="headerlink" title="数组的常见方法"></a>数组的常见方法</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice()</code>：从数组中<strong>提取</strong>指定的一个或者多个元素，返回结果为<strong>新的数组</strong>（不会改变原来的数组）。</p>
<p>备注：该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新数组 = 原数组.slice(开始位置的索引, 结束位置的索引);    //注意：包含开始索引，不包含结束索引</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.slice(2); //从第二个值开始提取</span><br><span class="line">var result2 = arr.slice(-2); //提取最后两个元素</span><br><span class="line">var result3 = arr.slice(2, 4); //提取从第二个到第四个之间的值（不包括第四个值）</span><br><span class="line">var result4 = arr.slice(4, 2); //空</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr:&quot; + JSON.stringify(arr));</span><br><span class="line">console.log(&quot;result1:&quot; + JSON.stringify(result1));</span><br><span class="line">console.log(&quot;result2:&quot; + JSON.stringify(result2));</span><br><span class="line">console.log(&quot;result3:&quot; + JSON.stringify(result3));</span><br><span class="line">console.log(&quot;result4:&quot; + JSON.stringify(result4));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result1:[&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result2:[&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result3:[&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">result4:[]</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：</p>
<p>很多前端开发人员会用 slice()将伪数组，转化为真数组。写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = Array.prototye.slice.call(arrayLike)</span><br><span class="line">或者</span><br><span class="line">array = [].slice.call(arrayLike)</span><br></pre></td></tr></table></figure>

<p>ES6 看不下去这种蹩脚的转化方法，于是出了一个新的 API：（专门用来将伪数组转化成真数组）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = Array.from(arrayLike)</span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice()</code>：从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong>（会改变原来的数组）。</p>
<p>备注：该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新数组 = 原数组.splice(起始索引index, 需要删除的个数, 第三个参数, 第四个参数...);</span><br></pre></td></tr></table></figure>

<p>上方语法中，第三个及之后的参数，表示：向原数组中添加新的元素，这些元素将会自动插入到开始位置索引的前面。</p>
<p>举例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line">var result1 = arr1.splice(1); //从第index为1的位置开始，删除元素</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr1：&quot; + JSON.stringify(arr1));</span><br><span class="line">console.log(&quot;result1：&quot; + JSON.stringify(result1));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1：[&quot;a&quot;]</span><br><span class="line">result1：[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line">var result2 = arr2.splice(-2); //删除最后两个元素</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr2：&quot; + JSON.stringify(arr2));</span><br><span class="line">console.log(&quot;result2：&quot; + JSON.stringify(result2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">result2：[&quot;e&quot;,&quot;f&quot;]</span><br></pre></td></tr></table></figure>

<p>举例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line">var result3 = arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr3：&quot; + JSON.stringify(arr3));</span><br><span class="line">console.log(&quot;result3：&quot; + JSON.stringify(result3));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr3：[&quot;a&quot;,&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result3：[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br></pre></td></tr></table></figure>

<p>举例4：（我们来看看<strong>第三个参数</strong>的用法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr4 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素</span><br><span class="line">var result4 = arr4.splice(1, 3, &quot;千古壹号&quot;, &quot;vae&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr4：&quot; + JSON.stringify(arr4));</span><br><span class="line">console.log(&quot;result4：&quot; + JSON.stringify(result4));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr4：[&quot;a&quot;,&quot;千古壹号&quot;,&quot;vae&quot;,&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result4：[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat()</code>：连接两个或多个数组，返回结果为<strong>新的数组</strong>。（不会改变原数组）</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新数组 = 数组1.concat(数组2, 数组3 ...);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3];</span><br><span class="line">var arr2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">var arr3 = [&quot;千古壹号&quot;, &quot;vae&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr1.concat(arr2);</span><br><span class="line"></span><br><span class="line">var result2 = arr2.concat(arr1, arr3);</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr1 =&quot; + JSON.stringify(arr1));</span><br><span class="line">console.log(&quot;arr2 =&quot; + JSON.stringify(arr2));</span><br><span class="line">console.log(&quot;arr3 =&quot; + JSON.stringify(arr3));</span><br><span class="line"></span><br><span class="line">console.log(&quot;result1 =&quot; + JSON.stringify(result1));</span><br><span class="line">console.log(&quot;result2 =&quot; + JSON.stringify(result2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr1 =[1,2,3]</span><br><span class="line">arr2 =[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">arr3 =[&quot;千古壹号&quot;,&quot;vae&quot;]</span><br><span class="line"></span><br><span class="line">result1 =[1,2,3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">result2 =[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,1,2,3,&quot;千古壹号&quot;,&quot;vae&quot;]</span><br></pre></td></tr></table></figure>

<p>从打印结果中可以看到，原数组并没有被修改。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><code>join()</code>：将数组转换为字符串，返回结果为<strong>转换后的字符串</strong>（不会改变原来的数组）。</p>
<p>补充：<code>join()</code>方法可以指定一个<strong>字符串</strong>作为参数，这个字符串将会成为数组中元素的<strong>连接符</strong>；如果不指定连接符，则默认使用 <code>,</code> 作为连接符，此时和 <code>toString()的效果是一致的</code>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新的字符串 = 原数组.join(参数); // 参数选填</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line"></span><br><span class="line">var result1 = arr.join(); // 这里没有指定连接符，所以默认使用 , 作为连接符</span><br><span class="line"></span><br><span class="line">var result2 = arr.join(&quot;-&quot;); // 使用指定的字符串作为连接符</span><br><span class="line"></span><br><span class="line">console.log(typeof arr); // 打印结果：object</span><br><span class="line">console.log(typeof result1); // 打印结果：string</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr =&quot; + JSON.stringify(arr));</span><br><span class="line">console.log(&quot;result1 =&quot; + JSON.stringify(result1));</span><br><span class="line">console.log(&quot;result2 =&quot; + JSON.stringify(result2));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上方代码中，最后三行的打印结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr =[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">result1 =a,b,c</span><br><span class="line">result2 =a-b-c</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p><code>reverse()</code>：反转数组，返回结果为<strong>反转后的数组</strong>（会改变原来的数组）。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反转后的数组  =  数组.reverse();</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">var result = arr.reverse(); // 将数组 arr 进行反转</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr =&quot; + JSON.stringify(arr));</span><br><span class="line">console.log(&quot;result =&quot; + JSON.stringify(result));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr =[&quot;f&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]</span><br><span class="line">result =[&quot;f&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]</span><br></pre></td></tr></table></figure>

<p>从打印结果可以看出，原来的数组已经被改变了。</p>
<h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h2><blockquote>
<p>sort()方法要好好理解。所以，我们单独用一大段来讲。</p>
</blockquote>
<p><code>sort()</code>：对数组的元素进行从小到大来排序（会改变原来的数组）。</p>
<h3 id="sort-方法举例：无参时"><a href="#sort-方法举例：无参时" class="headerlink" title="sort()方法举例：无参时"></a>sort()方法举例：无参时</h3><p>如果在使用 sort() 方法时不带参，则默认按照<strong>Unicode编码</strong>，从小到大进行排序。</p>
<p><strong>举例1</strong>：（当数组中的元素为字符串时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;f&quot;, &quot;c&quot;];</span><br><span class="line"></span><br><span class="line">var result = arr1.sort(); // 将数组 arr1 进行排序</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr1 =&quot; + JSON.stringify(arr1));</span><br><span class="line">console.log(&quot;result =&quot; + JSON.stringify(result));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 =[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</span><br><span class="line">result =[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>举例2</strong>：（当数组中的元素为数字时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr2 = [5, 2, 11, 3, 4, 1];</span><br><span class="line"></span><br><span class="line">var result = arr2.sort(); // 将数组 arr2 进行排序</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr2 =&quot; + JSON.stringify(arr2));</span><br><span class="line">console.log(&quot;result =&quot; + JSON.stringify(result));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 =[1,11,2,3,4,5]</span><br><span class="line">result =[1,11,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>上方的打印结果中，你会发现，使用 sort() 排序后，数字<code>11</code>竟然在数字<code>2</code>的前面。这是为啥呢？因为上面讲到了，<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>
<p>那如果我想让 arr2 里的数字，完全按照从小到大排序，怎么操作呢？继续往下看。</p>
<h3 id="sort-方法举例：带参时"><a href="#sort-方法举例：带参时" class="headerlink" title="sort()方法举例：带参时"></a>sort()方法举例：带参时</h3><p>如果在 sort()方法中带参，我们就可以<strong>自定义</strong>排序规则。具体做法如下：</p>
<p>我们可以在sort()添加一个回调函数，来指定排序规则。回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数</p>
<p>浏览器根据回调函数的返回值来决定元素的排序：（重要）</p>
<ul>
<li>如果返回一个大于0的值，则元素会交换位置</li>
<li>如果返回一个小于0的值，则元素位置不变</li>
<li>如果返回一个0，则认为两个元素相等，则不交换位置</li>
</ul>
<p><strong>代码举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr3 = [5, 2, 11, 3, 4, 1];</span><br><span class="line"></span><br><span class="line">// 自定义排序规则</span><br><span class="line">var result = arr3.sort(function(a, b) &#123;</span><br><span class="line">if (a &gt; b) &#123; // 如果 a 大于 b，则交换 a 和 b 的位置</span><br><span class="line">  return 1;</span><br><span class="line">&#125; else if (a &lt; b) &#123; // 如果 a 小于 b，则位置不变</span><br><span class="line">  return -1;</span><br><span class="line">&#125; else &#123; // 如果 a 等于 b，则位置不变</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr3 =&quot; + JSON.stringify(arr3));</span><br><span class="line">console.log(&quot;result =&quot; + JSON.stringify(result));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr3 =[1,2,3,4,5,11]</span><br><span class="line">result =[1,2,3,4,5,11]</span><br></pre></td></tr></table></figure>

<p>上方代码的写法太啰嗦了，其实也可以简化为如下写法：</p>
<p><strong>代码优化</strong>：（冒泡排序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr3 = [5, 2, 11, 3, 4, 1];</span><br><span class="line"></span><br><span class="line">// 自定义排序规则</span><br><span class="line">var result = arr3.sort(function(a, b) &#123;</span><br><span class="line">return a - b; // 升序排列</span><br><span class="line">// return b - a; // 降序排列</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;arr3 =&quot; + JSON.stringify(arr3));</span><br><span class="line">console.log(&quot;result =&quot; + JSON.stringify(result));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr3 =[1,2,3,4,5,11]</span><br><span class="line">result =[1,2,3,4,5,11]</span><br></pre></td></tr></table></figure>

<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组即：获取并操作数组中的每一个元素。在我们的实战开发中，使用得非常频繁。</p>
<p>遍历数组的方法包括：every()、filter()、forEach()、map()、some()</p>
<p>PS：这几个方法<strong>不会修改原数组</strong>。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组/boolean/无 = 数组.every/filter/forEach/map/some(</span><br><span class="line">                        function(item, index, arr)&#123;</span><br><span class="line">                                        程序和返回值；</span><br><span class="line">                        &#125;)</span><br></pre></td></tr></table></figure>

<p>有了这几种方法，就可以替代一些for循环了。下面依次来介绍。</p>
<h3 id="for循环-遍历"><a href="#for循环-遍历" class="headerlink" title="for循环 遍历"></a>for循环 遍历</h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;生命壹号&quot;,&quot;许嵩&quot;,&quot;永不止步&quot;];</span><br><span class="line">for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    console.log(arr[i]);  // arr[i]代表的是数组中的每一个元素i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180124_2008.png" alt="img"></p>
<h3 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach() 遍历"></a>forEach() 遍历</h3><blockquote>
<p><code>forEach()</code> 这种遍历方法只支持IE8以上的浏览器。IE8及以下的浏览器均不支持该方法。所以如果需要兼容IE8，则不要使用forEach，改为使用for循环来遍历即可。</p>
</blockquote>
<p>forEach()方法需要一个函数作为参数。这种函数，是由我们创建但是不由我们调用的，我们称为回调函数。</p>
<p>数组中有几个元素，该回调函数就会执行几次。执行完毕后，浏览器会将遍历到的元素。</p>
<p>回调函数中传递三个参数：</p>
<ul>
<li>第一个参数，就是当前正在遍历的元素</li>
<li>第二个参数，就是当前正在遍历的元素的索引</li>
<li>第三个参数，就是正在遍历的数组</li>
</ul>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;];</span><br><span class="line"></span><br><span class="line">arr.forEach(function(item, index, obj) &#123;</span><br><span class="line">console.log(&quot;item:&quot; + item);</span><br><span class="line">console.log(&quot;index:&quot; + index);</span><br><span class="line">console.log(&quot;obj:&quot; + obj);</span><br><span class="line">console.log(&quot;----------&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">item:王一</span><br><span class="line">index:0</span><br><span class="line">obj:王一,王二,王三</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">item:王二</span><br><span class="line">index:1</span><br><span class="line">obj:王一,王二,王三</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">item:王三</span><br><span class="line">index:2</span><br><span class="line">obj:王一,王二,王三</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>注意，forEach() 的返回值是 undefined。也就是说，它没有返回值。如果你尝试 <code>tempArry = arr.forEach()</code>这种方式来接收，是达不到效果的。</p>
<h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><p>解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是<strong>加工之后</strong>的新数组）。</p>
<p><strong>举例1</strong>：（拷贝的过程中改变数组元素的值）</p>
<p>有一个已知的数组arr1，我要求让arr1中的每个元素的值都加10，这里就可以用到 map 方法。代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">var arr2 = arr1.map(function (item, index) &#123;</span><br><span class="line">    return item + 10;  //让arr1中的每个元素加10</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180402_0938.png" alt="img"></p>
<p><strong>举例2</strong>：【重要案例】</p>
<p>将A数组中某个属性的值，存储到B数组中。代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [</span><br><span class="line">    &#123; name: &#x27;千古壹号&#x27;, age: &#x27;28&#x27; &#125;, &#123; name: &#x27;许嵩&#x27;, age: &#x27;32&#x27; &#125;</span><br><span class="line">];</span><br><span class="line">const arr2 = arr1.map(item =&gt; item.name); // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中</span><br><span class="line"></span><br><span class="line">console.log(&#x27;arr1:&#x27; + JSON.stringify(arr1));</span><br><span class="line">console.log(&#x27;arr2:&#x27; + JSON.stringify(arr2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1:[&#123;&quot;name&quot;:&quot;千古壹号&quot;,&quot;age&quot;:&quot;28&quot;&#125;,&#123;&quot;name&quot;:&quot;许嵩&quot;,&quot;age&quot;:&quot;32&quot;&#125;]</span><br><span class="line"></span><br><span class="line">arr2:[&quot;千古壹号&quot;,&quot;许嵩&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>map的应用场景，主要就是以上两种。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>解释：对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组（返回值就是这个新的数组）。</p>
<p><strong>举例1</strong>：找出数组 arr1 中大于4的元素，返回一个新的数组。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">var arr2 = arr1.filter(function(item, index) &#123;</span><br><span class="line">    return item &gt; 4; //将arr1中大于4的元素返回，组成新的数组</span><br><span class="line">&#125;);</span><br><span class="line">console.log(JSON.stringify(arr2));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6,5,6]</span><br></pre></td></tr></table></figure>

<p>上方代码的ES6写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter(item=&gt; item &gt; 4); //将arr1中大于4的元素返回，组成新的数组</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(arr2));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>举例2</strong>：</p>
<p>获取数组A中指定类型的对象，放到数组B中。代码举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [</span><br><span class="line">    &#123; name: &#x27;许嵩&#x27;, type: &#x27;一线&#x27; &#125;,</span><br><span class="line">    &#123; name: &#x27;周杰伦&#x27;, type: &#x27;过气&#x27; &#125;,</span><br><span class="line">    &#123; name: &#x27;邓紫棋&#x27;, type: &#x27;一线&#x27; &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter(item =&gt; item.type == &#x27;一线&#x27;); // 筛选出一线歌手</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(arr2));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;许嵩&quot;,&quot;type&quot;:&quot;一线&quot;&#125;,&#123;&quot;name&quot;:&quot;邓紫棋&quot;,&quot;type&quot;:&quot;一线&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="every-方法"><a href="#every-方法" class="headerlink" title="every()方法"></a>every()方法</h3><p><code>every()</code>：对数组中每一项运行回调函数，如果都返回true，every就返回true；如果有一项返回false，则停止遍历，此方法返回false。</p>
<p>注意：every()方法的返回值是boolean值，参数是回调函数。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;千古&quot;, &quot;宿敌&quot;, &quot;南山忆&quot;, &quot;素颜&quot;];</span><br><span class="line">var bool1 = arr1.every(function (element, index, array) &#123;</span><br><span class="line">    if (element.length &gt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(bool1);  //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false</span><br><span class="line"></span><br><span class="line">var arr2 = [&quot;千古&quot;, &quot;宿敌&quot;, &quot;南山&quot;, &quot;素颜&quot;];</span><br><span class="line">var bool2 = arr2.every(function (element, index, array) &#123;</span><br><span class="line">    if (element.length &gt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(bool2);  //输出结果：true。因为每个元素的长度都是两个字符。</span><br></pre></td></tr></table></figure>

<h3 id="some-方法"><a href="#some-方法" class="headerlink" title="some()方法"></a>some()方法</h3><p><code>some()</code>：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。</p>
<p>注意：some()方法的返回值是boolean值。</p>
<p>例子：数组扁平化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">even2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">				arr = [].concat(...arr);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;扩展运算符结果：&#x27;</span>)</span><br><span class="line">			<span class="built_in">console</span>.log(arr);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>解析：some()只要有一项返回true则停止遍历，也就是说若返回false则执行回调函数。</p>
<p>首先对于arr[0]，不是一个数组，返回false，执行回调函数。</p>
<p><code>...arr</code>之后变为了<code>1,[2, [3, [4, 5]]], 6</code>  <code>[].concat</code>是用来连接多个数组的，可以有多个参数，首先1会被添加进空数组，数组<code>[2, [3, [4, 5]]]</code>会被展开成<code>2, [3, [4, 5]]</code>被添加进数组。所以第一步执行完之后arr变成了<code>[1,2,[3, [4, 5]],6</code>]</p>
<p>第二步对于arr[1]来说也不是数组继续执行回调函数，<code>...arr=1,2,[3, [4, 5]],6</code>,<code>[].concat(...arr)=[1,2,3,[4,5],6]</code></p>
<p>第三步继续执行回调函数，<code>[].concat(...arr)=[1,2,3,4,5,6]</code></p>
<p>此时已经扁平化了，遍历完之后返回false，while循环结束。</p>
<h3 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce()方法"></a>reduce()方法</h3><blockquote>
<p>reduce的发音：[rɪ’djuːs]。中文含义是减少。</p>
</blockquote>
<p><code>reduce()</code>：为数组中的每一个元素，依次执行回调函数。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(</span><br><span class="line">    function(previousValue, item, index, arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;, initialValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>previousValue：上一次调用回调函数时的返回值，或者初始值</li>
<li>currentValue：当前正在处理的数组元素</li>
<li>currentIndex：当前正在处理的数组元素下标</li>
<li>array：调用reduce()方法的数组</li>
<li>initialValue：可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）</li>
</ul>
<p>备注：如果能熟练使用 reduce 的用法，将能替代很多其他的数组方法。</p>
<p><strong>举例1</strong>：</p>
<p>计算数组中所有元素项的总和。代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2, 0, 1, 9, 6];</span><br><span class="line">sumValue = arr.reduce(function(total, item) &#123; //  计算 arr 数组中，所有元素项的综合</span><br><span class="line">    return total + item;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;sumValue:&#x27; + sumValue); // 打印结果：18</span><br></pre></td></tr></table></figure>

<h2 id="数组的其他方法"><a href="#数组的其他方法" class="headerlink" title="数组的其他方法"></a>数组的其他方法</h2><h3 id="indexOf-和-lastIndexOf-：获取数据的索引"><a href="#indexOf-和-lastIndexOf-：获取数据的索引" class="headerlink" title="indexOf() 和 lastIndexOf()：获取数据的索引"></a>indexOf() 和 lastIndexOf()：获取数据的索引</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引值 = 数组.indexOf(value);</span><br><span class="line"></span><br><span class="line">索引值 = 数组.lastIndexOf(value);</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>indexOf(value)：从前往后索引，获取 value 在数组中的第一个下标。</li>
<li>lastIndexOf(value) ：从后往前索引，获取 value 在数组中的最后一个下标。</li>
</ul>
<p><strong>作用</strong>：</p>
<p>利用这个方法，我们可以判断某个值是否在指定的数组中。**如果没找到则返回<code>-1</code>**。</p>
<p> <strong>举例1</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;];</span><br><span class="line"></span><br><span class="line">console.log(arr.indexOf(&quot;c&quot;));       //从前往后，找第一个&quot;c&quot;在哪个位置</span><br><span class="line">console.log(arr.lastIndexOf(&quot;d&quot;));   //从后往前，找第一个&quot;d&quot;在哪个位置</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180126_1125.png" alt="img"></p>
<p><strong>举例2</strong>：判断某个值是否在数组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;29926392220&quot;, &quot;29965620629&quot;, &quot;28003663436&quot;, &quot; &quot;, &quot;28818504366&quot;];</span><br><span class="line"></span><br><span class="line">var str = [</span><br><span class="line">    &#123;name:&quot;smyh&quot;, id: &quot;12334&quot;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;name:&quot;vae&quot;, id: &quot;28818504366&quot;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">str.filter(item =&gt; &#123;</span><br><span class="line">    console.log(arr.indexOf(item.id));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(function(item, index, arr)&#123;return true&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：找出<strong>第一个</strong>满足「指定条件返回true」的元素。</p>
<p>备注：一旦找到符合条件的第一个元素，将不再继续往下遍历。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2, 3, 2, 5, 7, 6];</span><br><span class="line"></span><br><span class="line">let result = arr.find(function (item, index) &#123;</span><br><span class="line">    return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result);  //打印结果：5</span><br></pre></td></tr></table></figure>

<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findIndex(function(item, index, arr)&#123;return true&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：找出<strong>第一个</strong>满足「指定条件返回true」的元素的index。</p>
<p>举例：</p>
<blockquote>
<p>我们直接把上面的代码中的find方法改成findIndex，来看看效果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2, 3, 2, 5, 7, 6];</span><br><span class="line"></span><br><span class="line">let result = arr.findIndex(function (item, index) &#123;</span><br><span class="line">    return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result); //打印结果：3</span><br></pre></td></tr></table></figure>

<h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = Array.from(arrayLike)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：将<strong>伪数组</strong>或可遍历对象转换为<strong>真数组</strong>。</p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button&gt;按钮1&lt;/button&gt;</span><br><span class="line">&lt;button&gt;按钮2&lt;/button&gt;</span><br><span class="line">&lt;button&gt;按钮3&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let btnArray = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">    console.log(btnArray);</span><br><span class="line">    console.log(btnArray[0]);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的布局中，有三个button标签，我们通过<code>getElementsByTagName</code>获取到的<code>btnArray</code>实际上是<strong>伪数组</strong>，并不是真实的数组：</p>
<p><img src="http://img.smyhvae.com/20180402_1116.png" alt="img"></p>
<p>既然<code>btnArray</code>是伪数组，它就不能使用数组的一般方法，否则会报错：</p>
<p><img src="http://img.smyhvae.com/20180402_1121.png" alt="img"></p>
<p>解决办法：采用<code>Array.from</code>方法将<code>btnArray</code>这个伪数组转换为真数组即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(btnArray);</span><br></pre></td></tr></table></figure>

<p>然后就可以使用数组的一般方法了：</p>
<p><img src="http://img.smyhvae.com/20180402_1125.png" alt="img"></p>
<p><strong>伪数组与真数组的区别</strong>：</p>
<p>伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有 pop、join等属性。</p>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.of(value1, value2, value3)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：将一系列值转换成数组。</p>
<p><strong>举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = Array.of(1, &#x27;abc&#x27;, true);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="isArray-：判断是否为数组"><a href="#isArray-：判断是否为数组" class="headerlink" title="isArray()：判断是否为数组"></a>isArray()：判断是否为数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">布尔值 = Array.isArray(被检测的值) ;</span><br></pre></td></tr></table></figure>

<p>以前，我们会通过 <code>A instanceof B</code>来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有下面isArray()方法。</p>
<h3 id="toString-：转换数组"><a href="#toString-：转换数组" class="headerlink" title="toString()：转换数组"></a>toString()：转换数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串 = 数组.toString();</span><br></pre></td></tr></table></figure>

<p>解释：把数组转换成字符串，每一项用<code>,</code>分割。</p>
<h3 id="valueOf-：返回数组本身"><a href="#valueOf-：返回数组本身" class="headerlink" title="valueOf()：返回数组本身"></a>valueOf()：返回数组本身</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组本身 = 数组.valueOf();</span><br></pre></td></tr></table></figure>

<p>这个方法的意义不大。因为我们指直接写数组对象的名字，就已经是数组本身了。</p>
<h2 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h2><h3 id="splice-练习：数组去重"><a href="#splice-练习：数组去重" class="headerlink" title="splice()练习：数组去重"></a>splice()练习：数组去重</h3><p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建一个数组</span><br><span class="line">var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5];</span><br><span class="line"></span><br><span class="line">//去除数组中重复的数字</span><br><span class="line">//获取数组中的每一个元素</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  //console.log(arr[i]);</span><br><span class="line">  /*获取当前元素后的所有元素*/</span><br><span class="line">  for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">    //console.log(&quot;----&gt;&quot;+arr[j]);</span><br><span class="line">    //判断两个元素的值是否相等</span><br><span class="line">    if (arr[i] == arr[j]) &#123;</span><br><span class="line">      //如果相等则证明出现了重复的元素，则删除j对应的元素</span><br><span class="line">      arr.splice(j, 1);</span><br><span class="line">      //当删除了当前j所在的元素以后，后边的元素会自动补位</span><br><span class="line">      //此时将不会在比较这个元素吧，我需要在比较一次j所在位置的元素</span><br><span class="line">      //使j自减</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h3><p>清空数组，有以下几种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">array.splice(0);      //方式1：删除数组中所有项目</span><br><span class="line">array.length = 0;     //方式2：length属性可以赋值，在其它语言中length是只读</span><br><span class="line">array = [];           //方式3：推荐</span><br></pre></td></tr></table></figure>

<h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p><strong>问题</strong>：将一个字符串数组输出为<code>|</code>分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。</p>
<p>答案：</p>
<p>方式1：（不推荐）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;千古&quot;,&quot;宿敌&quot;,&quot;素颜&quot;];</span><br><span class="line">var str = arr[0];</span><br><span class="line">var separator = &quot;|&quot;;</span><br><span class="line">for(var i = 1;i&lt; arr.length;i++) &#123;</span><br><span class="line">    str += separator+arr[i];    //从第1个数组元素开始，每个元素前面加上符号&quot;|&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="http://img.smyhvae.com/20180126_1336.png" alt="img"></p>
<p>不推荐这种方式，因为：由于字符串的不变性，str拼接过多的话，容易导致内存溢出（很多个str都堆放在栈里）。</p>
<p>方式2：（推荐。通过array数组自带的api来实现）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;千古&quot;,&quot;宿敌&quot;,&quot;素颜&quot;];</span><br><span class="line"></span><br><span class="line">console.log(arr.join(&quot;|&quot;));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://img.smyhvae.com/20180126_1339.png" alt="img"></p>
<h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第i个和第length-i-1个进行交换。</p>
<p>答案：</p>
<p>方式1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(array) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    for (var i = array.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        newArr[newArr.length] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：（算法里比较常见的方式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function reverse(array)&#123;</span><br><span class="line">    for(var i=0;i&lt;array.length/2;i++)&#123;</span><br><span class="line">        var temp = array[i];</span><br><span class="line">        array[i] = array[array.length-1-i];</span><br><span class="line">        array[array.length-1-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式3：（数组自带的reverse方法）</p>
<p>现在我们学习了数组自带的api，我们就可以直接使用reverse()方法。</p>
<h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><p>问题：针对工资的数组[1500,1200,2000,2100,1800]，把工资超过2000的删除。</p>
<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1500, 1200, 2000, 2100, 1800];</span><br><span class="line"></span><br><span class="line">var arr2 = arr1.filter(function (ele, index, array) &#123;</span><br><span class="line">    if (ele &lt; 2000) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr1);</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://img.smyhvae.com/20180126_1435.png" alt="img"></p>
<h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><p>问题：找到数组[“c”,”a”,”z”,”a”,”x”,”a”]中每一个元素出现的次数。</p>
<p>分析：这道题建议用json数据来做，因为我们想知道a出现了几次，c出现了几次，x出现了几次。恰好<code>k:v ..  k:v</code>这种键值对的形式就比数组方便很多了。</p>
<p>键值对的形式：用key代表数组中的元素，用value代表元素出现的次数。</p>
<p>略难，答案暂略。</p>
<h3 id="练习5：数组去重"><a href="#练习5：数组去重" class="headerlink" title="练习5：数组去重"></a>练习5：数组去重</h3><p>问题：编写一个方法去掉一个数组中的重复元素。</p>
<p>分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。</p>
<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//    编写一个方法 去掉一个数组的重复元素</span><br><span class="line">    var arr = [1,2,3,4,5,2,3,4];</span><br><span class="line">    console.log(arr);</span><br><span class="line">    var aaa = fn(arr);</span><br><span class="line">    console.log(aaa);</span><br><span class="line">    //思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。</span><br><span class="line">    function fn(array)&#123;</span><br><span class="line">        var newArr = [];</span><br><span class="line">        for(var i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">            //开闭原则</span><br><span class="line">            var bool = true;</span><br><span class="line">            //每次都要判断新数组中是否有旧数组中的值。</span><br><span class="line">            for(var j=0;j&lt;newArr.length;j++)&#123;</span><br><span class="line">                if(array[i] === newArr[j])&#123;</span><br><span class="line">                    bool = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(bool)&#123;</span><br><span class="line">                newArr[newArr.length] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装类的介绍"><a href="#包装类的介绍" class="headerlink" title="包装类的介绍"></a>包装类的介绍</h3><p>我们都知道，js中的数据类型包括以下几种。</p>
<ul>
<li>基本数据类型：String、Number、Boolean、Null、Undefined</li>
<li>引用数据类型：Object</li>
</ul>
<p>JS为我们提供了<strong>三个包装类</strong>：</p>
<ul>
<li>String()：将基本数据类型字符串，转换为String对象。</li>
<li>Number()：将基本数据类型的数字，转换为Number对象。</li>
<li>Boolean()：将基本数据类型的布尔值，转换为Boolean对象。</li>
</ul>
<p>通过上面这这三个包装类，我们可以<strong>将基本数据类型的数据转换为对象</strong>。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(3);</span><br><span class="line"></span><br><span class="line">var str = new String(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">var bool = new Boolean(true);</span><br><span class="line"></span><br><span class="line">console.log(typeof num); // 打印结果：object</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：我们在实际应用中不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些<strong>不可预期</strong>的结果。</p>
<p>比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var boo1 = new Boolean(true);</span><br><span class="line">var boo2 = new Boolean(true);</span><br><span class="line"></span><br><span class="line">console.log(boo1 === boo2); // 打印结果竟然是：false</span><br></pre></td></tr></table></figure>

<p>再比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var boo3 = new Boolean(false);</span><br><span class="line"></span><br><span class="line">if (boo3) &#123;</span><br><span class="line">    console.log(&#x27;qianguyihao&#x27;); // 这行代码竟然执行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型不能添加属性和方法"><a href="#基本数据类型不能添加属性和方法" class="headerlink" title="基本数据类型不能添加属性和方法"></a>基本数据类型不能添加属性和方法</h3><p>方法和属性只能添加给对象，不能添加给基本数据类型。</p>
<p><strong>注意</strong>：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会<strong>临时使用包装类将其转换为对象</strong>，然后在调用对象的属性和方法；调用完以后，在将其转换为基本数据类型。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = 123;</span><br><span class="line"></span><br><span class="line">str = str.toString(); // 将 number 类型转换为 string 类型</span><br><span class="line">str.hello = &quot;千古壹号&quot;; // 添加属性</span><br><span class="line"></span><br><span class="line">console.log(typeof str); // 打印结果：string</span><br><span class="line">console.log(str.hello); // 打印结果：undefined</span><br></pre></td></tr></table></figure>

<p>再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法。</p>
<h2 id="作用域及let与const"><a href="#作用域及let与const" class="headerlink" title="作用域及let与const"></a>作用域及let与const</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><blockquote>
<p>变量在这个程序中一直存在，所有地方可读取。</p>
</blockquote>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><blockquote>
<p>变量只在函数内部存在，在函数外部变量失效。</p>
</blockquote>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><blockquote>
<p>let声明的变量只在let所在的代码块{}内有效，在{}外是不能访问的。</p>
</blockquote>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>任何位置都可使用</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>只能在函数作用域中使用，在全局作用域中不可使用</p>
<p>① 形参</p>
<p>② 在函数内部使用var声明的变量，没有用var声明的是全局变量</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote>
<p>let 声明的变量只在let命令所在的代码块内有效</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote>
<p>const声明一个只读的常量，使用时必须初始化，只能在块级作用域中访问，而且不能修改。使用const抵挡一的对象或者数组，实际上是可变的。</p>
</blockquote>
<h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><ul>
<li><p>在相同的作用域或者块级作用域中，不能使用let关键字来重置var关键字声明的变量。</p>
</li>
<li><p>在相同的作用域或者块级作用域中，不能使用let关键字来重置let关键字声明的变量。</p>
</li>
<li><p>在相应的作用域或者块级作用域中，不能使用var关键字来重置let关键字声明的变量。</p>
</li>
<li><p>let关键字在不同作用域或不同块级作用域中是可以冲i性能声明赋值的。</p>
</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><blockquote>
<p>document object model,文档对象模型。</p>
</blockquote>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><blockquote>
<p>构成HTML网页的最近本单元，网页中的每一部分都可以称之为是一个节点，比如html标签，属性，文本，知识，整个文档都是一个节点。</p>
</blockquote>
<p>虽然都是节点，但是实际上他们的具体类型是不同的。常见节点分为四类：</p>
<ul>
<li>文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。</li>
<li>元素节点（标签）：HTML标签。</li>
<li>属性节点（属性）：元素的属性。</li>
<li>文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。</li>
</ul>
<p>节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。</p>
<h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><p><strong>DOM</strong>：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。</p>
<p>DOM就是由节点组成的。</p>
<p><strong>解析过程</strong>： HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的<strong>属性</strong>。</p>
<p><strong>DOM树</strong>：（一切都是节点）</p>
<p>DOM的数据结构如下：</p>
<p><img src="http://img.smyhvae.com/20180126_2105.png" alt="img"></p>
<p>上图可知，<strong>在HTML当中，一切都是节点</strong>（非常重要）。节点的分类，在上一段中，已经讲了。</p>
<p>整个html文档就是一个文档节点。所有的节点都是Object。</p>
<h3 id="DOM可以做什么"><a href="#DOM可以做什么" class="headerlink" title="DOM可以做什么"></a>DOM可以做什么</h3><ul>
<li>找对象（元素节点）</li>
<li>设置元素的属性值</li>
<li>设置元素的样式</li>
<li>动态创建和删除元素</li>
<li>事件的触发响应：事件源、事件、事件的驱动程序</li>
</ul>
<h3 id="document节点的属性"><a href="#document节点的属性" class="headerlink" title="document节点的属性"></a>document节点的属性</h3><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p>返回当前文档的标题</p>
<h4 id="location属性"><a href="#location属性" class="headerlink" title="location属性"></a>location属性</h4><p>返回文档的路径</p>
<p><code>document.location.href</code></p>
<h2 id="元素节点的获取"><a href="#元素节点的获取" class="headerlink" title="元素节点的获取"></a>元素节点的获取</h2><p>DOM节点的获取方式其实就是<strong>获取事件源的方式</strong>。关于事件，上一篇文章中已经讲到了。</p>
<p>想要操作元素节点，必须首先要找到该节点。有四种方式可以获取DOM节点：</p>
<h3 id="通过id获取"><a href="#通过id获取" class="headerlink" title="通过id获取"></a>通过id获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>); <span class="comment">//方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>); <span class="comment">//方式二：通过 标签名 获取 元素节点数组，所以有s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;hehe&quot;</span>); <span class="comment">//方式三：通过 类名 获取 元素节点数组，所以有s</span></span><br><span class="line"><span class="keyword">var</span> arr3=</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;css选择器&#x27;</span>)<span class="comment">//获取一个</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;css选择器&#x27;</span>)<span class="comment">//获取所有</span></span><br></pre></td></tr></table></figure>

<h3 id="通过标签名获取"><a href="#通过标签名获取" class="headerlink" title="通过标签名获取"></a>通过标签名获取</h3><p>返回的是伪数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=getElementById(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> list=ul.getElementByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="通过类名获取"><a href="#通过类名获取" class="headerlink" title="通过类名获取"></a>通过类名获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;hehe&quot;</span>); <span class="comment">//方式三：通过 类名 获取 元素节点数组，所以有s</span></span><br></pre></td></tr></table></figure>



<h3 id="通过css选择器获取"><a href="#通过css选择器获取" class="headerlink" title="通过css选择器获取"></a>通过css选择器获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3=</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;css选择器&#x27;</span>)<span class="comment">//只获取第一个</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;css选择器&#x27;</span>)<span class="comment">//获取满足条件的所有元素</span></span><br></pre></td></tr></table></figure>

<h2 id="DOM访问关系的获取"><a href="#DOM访问关系的获取" class="headerlink" title="DOM访问关系的获取"></a>DOM访问关系的获取</h2><p>DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下：</p>
<p><img src="http://img.smyhvae.com/20180126_2140.png" alt="img"></p>
<p>节点的访问关系，是以<strong>属性</strong>的方式存在的。</p>
<p>JS中的<strong>父子兄</strong>访问关系：</p>
<p><img src="http://img.smyhvae.com/20180126_2145.png" alt="img"></p>
<p>这里我们要重点知道<strong>parentNode</strong>和<strong>children</strong>这两个属性的用法。下面分别介绍。</p>
<h3 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h3><p>调用者就是节点。一个节点只有一个父节点，调用方式就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">节点.parentNode</span><br></pre></td></tr></table></figure>

<h3 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h3><p><strong>1、下一个节点 | 下一个元素节点</strong>：</p>
<blockquote>
<p>Sibling的中文是<strong>兄弟</strong>。</p>
</blockquote>
<p>（1）nextSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指下一个元素节点（标签）。</li>
</ul>
<p>（2）nextElementSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取下一个<strong>元素节点</strong>，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling</span><br></pre></td></tr></table></figure>

<p><strong>2、前一个节点 | 前一个元素节点</strong>：</p>
<blockquote>
<p>previous的中文是：前一个。</p>
</blockquote>
<p>（1）previousSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指前一个元素节点（标签）。</li>
</ul>
<p>（2）previousElementSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取前一个<strong>元素节点</strong>，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling</span><br></pre></td></tr></table></figure>

<p><strong>3、补充</strong>：获得任意一个兄弟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">节点自己.parentNode.children[index];  //随意得到兄弟节点</span><br></pre></td></tr></table></figure>

<h3 id="获取单个的子节点"><a href="#获取单个的子节点" class="headerlink" title="获取单个的子节点"></a>获取单个的子节点</h3><p><strong>1、第一个子节点 | 第一个子元素节点</strong>：</p>
<p>（1）firstChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指第一个子元素节点（标签）。</li>
</ul>
<p>（2）firstElementChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取第一个<strong>子元素节点</strong>，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个子元素节点 = 节点.firstElementChild || 节点.firstChild</span><br></pre></td></tr></table></figure>

<p><strong>2、最后一个子节点 | 最后一个子元素节点</strong>：</p>
<p>（1）lastChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指最后一个子元素节点（标签）。</li>
</ul>
<p>（2）lastElementChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取最后一个<strong>子元素节点</strong>，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild</span><br></pre></td></tr></table></figure>

<h3 id="获取所有的子节点"><a href="#获取所有的子节点" class="headerlink" title="获取所有的子节点"></a>获取所有的子节点</h3><p>（1）<strong>childNodes</strong>：标准属性。返回的是指定元素的<strong>子节点</strong>的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。</p>
<ul>
<li>火狐 谷歌等高本版会把换行也看做是子节点。</li>
</ul>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子节点数组 = 父节点.childNodes;   //获取所有节点。</span><br></pre></td></tr></table></figure>

<p>（2）<strong>children</strong>：非标准属性。返回的是指定元素的<strong>子元素节点</strong>的集合。【重要】</p>
<ul>
<li>它只返回HTML节点，甚至不返回文本节点。</li>
<li>在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。</li>
</ul>
<p>虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。</p>
<p>用法：（<strong>用的最多</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子节点数组 = 父节点.children;   <span class="comment">//获取所有节点。用的最多。</span></span><br></pre></td></tr></table></figure>

<h2 id="创建页面元素"><a href="#创建页面元素" class="headerlink" title="创建页面元素"></a>创建页面元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-tag">h1</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">	<span class="attribute">color</span>: <span class="number">#00A7DE</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//1.创建div元素</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//2.将元素添加到父节点中</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.body.appendChild(div);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//创建文本节点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> text=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;我是一个文本节点&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.appendChild(text);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//创建属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> attr=<span class="built_in">document</span>.createAttribute(<span class="string">&quot;title&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	attr.value=<span class="string">&#x27;haha&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//设置属性节点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.setAttributeNode(attr);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> style=<span class="built_in">document</span>.createAttribute(<span class="string">&#x27;style&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	style.value=<span class="string">&#x27;width:100px;height:100px; background-color:red;&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.setAttributeNode(style);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="操作页面元素"><a href="#操作页面元素" class="headerlink" title="操作页面元素"></a>操作页面元素</h2><h3 id="元素节点的方法"><a href="#元素节点的方法" class="headerlink" title="元素节点的方法"></a>元素节点的方法</h3><p>① <code>getAttribute(&#39;属性名&#39;)</code></p>
<p>如果有属性，返回属性值</p>
<p>如果没有属性，返回null</p>
<p>② <code>setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)</code></p>
<p>③ <code>removeAttribute(&#39;属性名&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #00BFFF;height: 200px;width: 200px;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		hahah</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//1.创建div元素</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//2.将元素添加到父节点中</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.body.appendChild(div);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//创建文本节点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> text=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;我是一个文本节点&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.appendChild(text);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//设置属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.setAttribute(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;width: 200px;height: 200px;background-color: red;line-height: 200px;&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.setAttribute(<span class="string">&#x27;align&#x27;</span>,<span class="string">&#x27;center&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="comment">//删除属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	div.removeAttribute(<span class="string">&#x27;align&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式"></a>操作内联样式</h2><h3 id="元素节点的style属性"><a href="#元素节点的style属性" class="headerlink" title="元素节点的style属性"></a>元素节点的style属性</h3><blockquote>
<p>Element节点本身提供style属性，用来操作css样式。style属性指向一个对象，用来读写页面元素的行内css样式</p>
<p><strong>通过style属性设置的样式都是内联样式，如果在样式中写了<code>!important</code>,js也无法改变。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">	div.style.width=<span class="string">&#x27;300px&#x27;</span>;</span><br><span class="line">	div.style.height=<span class="string">&#x27;300px&#x27;</span>;</span><br><span class="line">	div.style.backgroundColor=<span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">	div.style.cssFloat=<span class="string">&#x27;left&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="改写规则"><a href="#改写规则" class="headerlink" title="改写规则"></a>改写规则</h4><p>元素的style对象对应元素的style属性，style对象中的样式与元素style属性中的样式名是一一对应的，但是需要一点点的<strong>改写规则</strong>。</p>
<ul>
<li>将横杠从css属性名中去除，然后将横杠后的第一个字母大写</li>
<li>css属性名是JavaScript的保留字的，在属性名之前需要加上字符串css</li>
<li>style对象的属性值都是字符串，而且包括单位。</li>
</ul>
<h4 id="cssText"><a href="#cssText" class="headerlink" title="cssText"></a>cssText</h4><p>style对象的cssText属性可以用来读写或删除整个style属性，因此刚才的写法可以改写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.style.cssText=<span class="string">&quot;width: 100px; height: 100px;background-color: #00BFFF;&quot;</span></span><br></pre></td></tr></table></figure>

<p>删除整个style属性可以使用<code>div.style.cssYext=&#39;&#39;</code></p>
<h4 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.style.height<span class="comment">//无法读取样式表中的样式，只能读取内联样式。</span></span><br></pre></td></tr></table></figure>

<h3 id="currentStyle"><a href="#currentStyle" class="headerlink" title="currentStyle"></a>currentStyle</h3><blockquote>
<p>只能在IE中使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(div.currentStyle.width);</span><br></pre></td></tr></table></figure>

<h3 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h3><blockquote>
<p>获取当前元素的样式，这个方法是window的方法，可以直接使用。</p>
<p>需要两个参数，第一个参数是需要获取的元素，第二个参数是伪元素，一般都传null</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(getComputedStyle(box1,<span class="literal">null</span>).width)<span class="comment">//会返回具体的值，如果获取的样式没有设置，会获真实的值，而不是auto。</span></span><br></pre></td></tr></table></figure>

<h3 id="clientWidth和clientHeight"><a href="#clientWidth和clientHeight" class="headerlink" title="clientWidth和clientHeight"></a>clientWidth和clientHeight</h3><p>这两个属性可以获取元素的可见宽度和高度</p>
<p>这些属性都是不带px的返回的是一个数字，可以直接进行计算，</p>
<p>会获取元素的宽度和高度，包括内容区和内边距</p>
<p>这些属性都是只读的，不能修改。</p>
<h3 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a>offsetWidth和offsetHeight</h3><p>可以获取元素的整个宽度和高度，包括内容区，内边距和边框</p>
<h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><p>可以返回当前元素的定位父元素</p>
<p>会获取到离当前元素最近的开启了定位的祖先元素</p>
<p>如果所有的祖先元素都没有开启定位，则会返回body</p>
<h3 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h3><p>分别返回当前元素相对于定位父元素的水平偏移量和垂直偏移量</p>
<h3 id="scrollWidth和scrollHeight"><a href="#scrollWidth和scrollHeight" class="headerlink" title="scrollWidth和scrollHeight"></a>scrollWidth和scrollHeight</h3><p>返回元素的整个滚动区域的宽度和高度</p>
<h3 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a>scrollLeft和scrollTop</h3><p>分别获取水平滚动条滚动的距离和垂直滚动条滚动的距离</p>
<p><strong>示例代码：阅读协议后才可注册</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-id">#p</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;p&#x27;</span>&gt;</span>百度是全球最大的中文搜索引擎，是中国最大的以信息和知识为核心的互联网综合服务公司，更是全球领先的人工智能平台型公司。2000年1月1日创立于中关村，公司创始人李彦宏拥有“超链分析”技术专利，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。</span><br><span class="line">百度LOGO</span><br><span class="line">百度LOGO</span><br><span class="line">百度作为全球最大的中文搜索引擎，百度每天响应来自100余个国家和地区的数十亿次搜索请求，是网民获取中文信息的最主要入口。百度以“用科技让复杂的世界更简单”为使命，不断坚持技术创新，致力于“成为最懂用户，并能帮助人们成长的全球顶级高科技公司”。</span><br><span class="line">百度是中国最大的以信息和知识为核心的互联网综合服务公司。在AI驱动下，百度的移动生态是中国最大的以信息和知识为核心的移动生态，以百家号、智能小程序和托管页为主要支柱。2019年百度用户规模突破10亿。百度App日活跃用户2.22亿，信息流位居中国第一。百家号创作者达到300万。百度智能小程序是国内唯一完全开源的小程序平台，月活用户规模破3.54亿。百度知道、百度百科、百度文库等六大知识类产品累计生产超10亿条高质量内容，构建了中国最大的知识内容体系。</span><br><span class="line">百度是全球领先的人工智能平台型公司。百度大脑是中国唯一的“软硬一体AI大生产平台”，是百度AI的集大成，对外全方位输出超过250多项AI能力。飞桨是中国首个全面开源开放、功能完备的产业级深度学习平台，是中国自主研发的“智能时代的操作系统”。百度智能云是百度AI To B业务的重要承载者和输出者，是产业智能化领导者。小度助手是中国最大的对话式人工智能操作系统，拥有中国市场规模最大、最繁荣的对话式人工智能生态，2020年3月，小度助手语音交互次数超过65亿次。作为全球最大自动驾驶开放平台，Apollo代表中国最强自动驾驶实力，被知名研究公司Navigant Research列为全球四大自动驾驶领域领导者之一。目前已形成自动驾驶、车路协同、智能车联三大开放平台。自动驾驶方面，超过十项中国第一，技术实力领跑行业。智能交通方面，百度“ACE交通引擎”是全球首个车路行融合的全栈式智能交通解决方案。</span><br><span class="line">百度以技术创新为信仰，在创新投入、研发布局、人才引进方面均走在国际前列。根据国家工业信息安全发展研究中心《人工智能中国专利技术分析报告》显示，2019年中国人工智能专利申请量排名中，百度以5712件位列第一。</span><br><span class="line">百度一直秉承着“科技为更好”的社会责任理念，坚持运用创新技术，聚焦于解决社会问题，履行企业公民的社会责任，为帮助全球用户创造更加美好的生活而不断努力。百度成立3亿元疫情及公共卫生安全攻坚专项基金，用于支持新型冠状病毒等新疾病的治愈药物筛选、研发等一系列抗击疫情工作，以及更长期的社会公共卫生安全信息科普和传播等。百度“AI寻人”项目与民政部进行合作，借助跨年龄人脸识别技术，已帮助超10499个走失者与家人团聚。目前，百度“共益计划”已收到超过300家公益组织机构的入驻申请，帮助200多家在百度上进行了免费推广，涵盖了教育、环保、医疗、扶贫等广阔的社会议题。 [1]  [3-5] </span><br><span class="line"></span><br><span class="line">公司理念</span><br><span class="line">百度是一家持续创新的，以“用科技让复杂的世界更简单”为使命的高科技公司。</span><br><span class="line">百度使命：用科技让复杂的世界更简单</span><br><span class="line">mission：Make the complicated world simpler through technology.</span><br><span class="line">百度愿景：成为最懂用户，并能帮助人们成长的全球顶级高科技公司 [4] </span><br><span class="line">vision：To be a top global technology company which best understands users’needs and enables their growth.</span><br><span class="line">百度核心价值观：简单可依赖</span><br><span class="line">百度文化论语</span><br><span class="line">人一定要做自己喜欢且擅长的事情·认准了，就去做；不跟风，不动摇· 专注如一· 保持学习心态· 公司离破产永远只有30天· 每个人都要捡起地上的垃圾· 百度不仅是李彦宏的，更是每一个百度人的· 一定要找最优秀的人才· 给最自由的空间· 允许试错· 证明自己，用结果说话· 让优秀人才脱颖而出· 愿意被挑战· 说话不绕弯子· 对事不对人· 百度没有公司政治· 遇到新事物，先看看别人是怎么干的· 听多数人的意见，和少数人商量，自己做决定· 一个人最重要的能力是判断力· 用流程解决共性问题· 创新求变· 不唯上· 问题驱动· 让数据说话· 高效率执行· 少许诺，多兑现· 把事情做到极致· 用户需求决定一切· 让产品简单，再简单· 迅速迭代，越变越美· 你不是孤军· 打破部门樊篱· 主动分享· 帮助别人，成就自己· 只把最好的成果传递给下一环节· 从可信赖到可依赖</span><br><span class="line">人才理念</span><br><span class="line">招最好的人，给最大的空间，看最后的结果，让优秀人才脱颖而出。</span><br><span class="line">“互联网公司，最有价值的就是人。我们的办公室、服务器会折旧，但一个公司，始终在增值的就是公司的每一位员工。”</span><br><span class="line">“对于一个人才，我们更多注重的是，你能不能够创造，为自身创造价值，给用户带来更好的体验，这是百度所关心的，所看重的。”——李彦宏</span><br><span class="line">财报数据</span><br><span class="line">2015年第四季度财报显示，百度营收为186.99亿元人民币，同比增长33.1%，其中移动营收占比持续上升达到56%；2015年全年百度总营收为663.82亿元人民币，同比增长35.3%，业绩超出华尔街预期。百度股价盘后大涨11.24%，收盘报176美元。 [6] </span><br><span class="line">2016年第四季度及全年未经审计的财务报告。移除去哪儿影响，百度第四季度营收为182.12亿人民币（约合26.23亿美元），与去年同期持平，其中移动营收占比65%；2016年度总营收为705.49亿人民币（约合101.61亿美元），同比增长11.9%。百度2016年第四季度业绩符合华尔街预期。 [7] </span><br><span class="line">2017年四季度，百度营收为236亿元人民币（约合36.2亿美元），同比增长29%，其中移动营收占比持续上升至76%。2017年全年百度总营收为848亿元人民币（约合130.3亿美元），同比增长20%。2017年四季度业绩与全年业绩均超出华尔街预期。移除百度移动游戏与百度外卖影响，百度预计在2018年第一季度，百度的净收入总额将会介于198.6亿元人民币（约合30.5亿美元）到209.7亿元人民币（约合32.2亿美元），同比增长29%至36%。这一指标同样超出华尔街预期。 [8] </span><br><span class="line">2018年第四季度及全年未经审计的财务报告。数据显示，本季度百度营收272亿元人民币（约合39.6亿美元），同比增长22%，超出华尔街预期；净利润21亿元（约合3.03亿美元）。2018年度总营收为1,023亿人民币（约合148.8亿美元）。 [9] </span><br><span class="line">2019年第四季度及全年未经审计的财务报告。第四季度百度实现营收289亿元人民币，归属百度的净利润达到92亿元人民币 （非美国通用会计准则），同比增长95%。2019年年营收为1074亿元人民币。 [10] </span><br><span class="line">2020年第一季度未经审计的财务报告。数据显示：第一季度百度营收225亿元，净利润（Non-GAAP）31亿元，同比增长219%。 [11]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span>/&gt;</span>我已阅读该协议</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">		<span class="keyword">let</span> p=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">		<span class="keyword">let</span> inputs=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>);</span></span><br><span class="line"><span class="javascript">		p.onscroll=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">if</span>(p.scrollHeight-p.scrollTop&lt;=p.clientHeight)</span></span><br><span class="line"><span class="javascript">			&#123;</span></span><br><span class="line"><span class="javascript">				inputs[<span class="number">0</span>].disabled=<span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">				inputs[<span class="number">1</span>].disabled=<span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="className属性"><a href="#className属性" class="headerlink" title="className属性"></a>className属性</h3><blockquote>
<p>className属性设置或返回元素的class属性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">12.5rem</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#00BFFF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span></span><br><span class="line">			你好</span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> box=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			box.className=<span class="string">&#x27;box&#x27;</span></span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="各主要浏览器的内核和引擎"><a href="#各主要浏览器的内核和引擎" class="headerlink" title="各主要浏览器的内核和引擎"></a>各主要浏览器的内核和引擎</h2><blockquote>
<p>一个完整的浏览器包含浏览器内核和浏览器大的外壳，浏览器的核心–内核分为两部分，渲染引擎和js引擎。</p>
</blockquote>
<p>浏览器的内核主要值得是浏览器的渲染引擎，代表有Trident（IE），Gecko（firefox），Webkit（Safari和chrome）</p>
<p>opera和Google一起研发了blink引擎，国内各种chrome系的浏览器（360，UC，QQ，2345）都用的是blink引擎。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><blockquote>
<p>解构赋值是对赋值运算符的扩展。</p>
<p>它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁且易读，语义更加清晰明了，也方便了复杂对象中数据字段获取。</p>
</blockquote>
<h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3><ul>
<li>基本</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可嵌套</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b,c]=[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//[2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可忽略</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不完全解构</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>剩余运算符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>解构默认值</p>
<p>当解构模式有匹配结果时，且匹配结果是undefinded时，会触发默认值作为返回结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象模式的解构"><a href="#对象模式的解构" class="headerlink" title="对象模式的解构"></a>对象模式的解构</h3><blockquote>
<p>解析对象时左边的变量名必须和右边的对象的属性名相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options=&#123;</span><br><span class="line">		<span class="attr">height</span>:<span class="number">100</span>,</span><br><span class="line">		<span class="attr">width</span>:<span class="number">200</span>,</span><br><span class="line">		<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> &#123;a,b,c&#125;=options;</span><br><span class="line">	<span class="comment">// console.log(height);</span></span><br><span class="line">	<span class="comment">// console.log(width);</span></span><br><span class="line">	<span class="comment">// console.log(color);</span></span><br><span class="line">	<span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">	<span class="built_in">console</span>.log(b);<span class="comment">//undefined</span></span><br><span class="line">	<span class="built_in">console</span>.log(c);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li><p>基本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">&#x27;ddd&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可嵌套可忽略</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>不完全解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>剩余运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>解构默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><blockquote>
<p>扩展运算符是三个点，它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  </span><br><span class="line"><span class="comment">// 1 2 3  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)  </span><br><span class="line"><span class="comment">// 1 2 3 4 5  </span></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]  </span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>该运算符主要用于函数调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;  </span><br><span class="line">array.push(...items);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> x + y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];  </span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><blockquote>
<p>对象中的扩展运算符用于取出参数对象中的所有可遍历睡醒，拷贝到当前对象中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1, <span class="attr">b</span>: <span class="string">&#x27;2-edited&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//  &#123;a: 1, b: &quot;2-edited&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子扩展运算符拷贝的对象是<em>基础数据类型</em>，因此对<code>obj2</code>的修改并不会影响<code>obj1</code>，如果改成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123;<span class="attr">nickName</span>: <span class="string">&#x27;d&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1&#125;;</span><br><span class="line">obj2.c.nickName = <span class="string">&#x27;d-edited&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数组的扩展运算符"><a href="#数组的扩展运算符" class="headerlink" title="数组的扩展运算符"></a>数组的扩展运算符</h3><ul>
<li><p>将数组转换为参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以复制数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将字符串转为真正的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h2><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><blockquote>
<p>同一个构造函数的多个实例之间无法共享属性，从而造成系统资源的浪费。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.meow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">&#x27;二毛&#x27;</span>, <span class="string">&#x27;黑色&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.meow === cat2.meow</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>
<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>
<h3 id="prototype属性的作用"><a href="#prototype属性的作用" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h3><blockquote>
<p>JavaScript继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享，也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">&#x27;大毛&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">&#x27;二毛&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &#x27;white&#x27;</span></span><br><span class="line">cat2.color <span class="comment">// &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &quot;yellow&quot;</span></span><br><span class="line">cat2.color <span class="comment">// &quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &#x27;black&#x27;</span></span><br><span class="line">cat2.color <span class="comment">// &#x27;yellow&#x27;</span></span><br><span class="line">Animal.prototype.color <span class="comment">// &#x27;yellow&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is walking&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h3><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>
<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyArray = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">MyArray.prototype.constructor = MyArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> MyArray();</span><br><span class="line">mine.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mine.length <span class="comment">// 3</span></span><br><span class="line">mine <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。 </p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>
<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.constructor === F <span class="comment">// true</span></span><br><span class="line">f.constructor === <span class="built_in">RegExp</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>
<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constr</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Constr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.constructor();</span><br><span class="line">y <span class="keyword">instanceof</span> Constr <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constr.prototype.createCopy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>
<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// false</span></span><br><span class="line">Person.prototype.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: C,</span><br><span class="line">  <span class="attr">method1</span>: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">C.prototype.method1 = <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>
<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line">f.constructor.name <span class="comment">// &quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><blockquote>
<p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v instanceof Vehicle</span><br><span class="line">// 等同于</span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型。由于<strong>instanceof</strong>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="built_in">this</span>._foo = foo;</span><br><span class="line">    <span class="built_in">this</span>._bar = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><blockquote>
<p>让一个构造函数继承另一个构造函数，分为两步来实现，第一步是在子类的构造函数中调用父类的构造函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = new Super();</span><br></pre></td></tr></table></figure>

<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Shape() &#123;</span><br><span class="line">  this.x = 0;</span><br><span class="line">  this.y = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = function (x, y) &#123;</span><br><span class="line">  this.x += x;</span><br><span class="line">  this.y += y;</span><br><span class="line">  console.info(&#x27;Shape moved.&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一步，子类继承父类的实例</span><br><span class="line">function Rectangle() &#123;</span><br><span class="line">  Shape.call(this); // 调用父类构造函数</span><br><span class="line">&#125;</span><br><span class="line">// 另一种写法</span><br><span class="line">function Rectangle() &#123;</span><br><span class="line">  this.base = Shape;</span><br><span class="line">  this.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二步，子类继承父类的原型</span><br><span class="line">Rectangle.prototype = Object.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rect = new Rectangle();</span><br><span class="line"></span><br><span class="line">rect instanceof Rectangle  // true</span><br><span class="line">rect instanceof Shape  // true</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassB.prototype.print = function() &#123;</span><br><span class="line">  ClassA.prototype.print.call(this);</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h2 id="Object对象的相关方法"><a href="#Object对象的相关方法" class="headerlink" title="Object对象的相关方法"></a>Object对象的相关方法</h2><h3 id="1-Object-getPrototypeOf"><a href="#1-Object-getPrototypeOf" class="headerlink" title="1. Object.getPrototypeOf()"></a>1. Object.getPrototypeOf()</h3><blockquote>
<p>该方法返回参数对象的原型，这是获取原型对象的标准方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="2-Object-create"><a href="#2-Object-create" class="headerlink" title="2. Object.create()"></a>2. Object.create()</h3><blockquote>
<p>该方法接受一个对象作为参数，然后比它为原型，返回一个实例对象，该实例完全继承原型对象的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">Object</span>.create(A);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(B) === A <span class="comment">// true</span></span><br><span class="line">B.print() <span class="comment">// hello</span></span><br><span class="line">B.print === A.print <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line">obj1.p = <span class="number">2</span>;</span><br><span class="line">obj2.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<h3 id="3-Object-keys方法"><a href="#3-Object-keys方法" class="headerlink" title="3.Object.keys方法"></a>3.<code>Object.keys</code>方法</h3><blockquote>
<p>用于遍历对象属性的一个方法，它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat= &#123; </span><br><span class="line"><span class="attr">name</span>:’mini’, </span><br><span class="line"><span class="attr">age</span>:<span class="number">2</span>, </span><br><span class="line"><span class="attr">color</span>:’yellow’, </span><br><span class="line"><span class="attr">desc</span>:”cute” </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(cat)); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;color&quot;, &quot;desc&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Object-values-方法"><a href="#4-Object-values-方法" class="headerlink" title="4. Object.values()方法"></a><code>4. Object.values()方法</code></h3><blockquote>
<p>返回一个数组，成员是参数对象自身的（不含继承的）所有可便利属性的键值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;  </span><br><span class="line"><span class="built_in">Object</span>.values(obj)  </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure>

<p>返回数组的成员顺序，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b,c,a。该方法只返回对象自身的可遍历属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;  </span><br><span class="line"><span class="built_in">Object</span>.values(obj)  </span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]  </span></span><br></pre></td></tr></table></figure>

<p>如果Object.calues方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)  </span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]  </span></span><br></pre></td></tr></table></figure>

<h3 id="5-Object-hasOwnProperty"><a href="#5-Object-hasOwnProperty" class="headerlink" title="5.Object.hasOwnProperty()"></a><code>5.Object.hasOwnProperty()</code></h3><blockquote>
<p>判断对象自身属性中是否具有指定的属性。</p>
</blockquote>
<p>在某个对象是否拥有某个属性，判断的方法有很多，常用的方法就是object.hasOwnProperty(‘×××’)，这个方法是不包括对象原型链上的方法的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;fei&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>))<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>以上，obj对象存在的name属性的时候，调用这个方法才是返回true，我们知道其实每个对象实例的原型链上存在toString方法，在这里打印false，说明这个方法只是表明实例对象的属性，不包括原型链上的属性。</p>
<h3 id="6-Object-getOwmPropertyNames-方法"><a href="#6-Object-getOwmPropertyNames-方法" class="headerlink" title="6.Object.getOwmPropertyNames()方法"></a>6.<code>Object.getOwmPropertyNames()方法</code></h3><blockquote>
<p>返回对象的所有自身属性的属性名（包括不可枚举的属性）组成的数组，但不会获取原型链上的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a,aa</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.aa = aa;</span><br><span class="line">  <span class="built_in">this</span>.getA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">A.prototype.aaa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> A(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>);</span><br><span class="line">B.myMethodA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 不可枚举方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(B, <span class="string">&#x27;myMethodB&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(B); <span class="comment">// [&quot;a&quot;, &quot;aa&quot;, &quot;getA&quot;, &quot;myMethodA&quot;, &quot;myMethodB&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-Object-assign"><a href="#7-Object-assign" class="headerlink" title="7.Object.assign()"></a>7.<code>Object.assign()</code></h3><blockquote>
<p>用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>1、如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br>2、如果只有一个参数，Object.assign会直接返回该参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;  </span><br><span class="line">Object.assign(obj) === obj // true  </span><br></pre></td></tr></table></figure>

<p>3、如果该参数不是对象，则会先转成对象，然后返回。<br>4、由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。<br>5、Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;  </span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);  </span><br><span class="line">obj1.a.b = 2;  </span><br><span class="line">obj2.a.b // 2  </span><br></pre></td></tr></table></figure>

<p>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p>（ 1 ）为对象添加属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;  </span><br><span class="line">    constructor(x, y) &#123;  </span><br><span class="line">        Object.assign(this, &#123;x, y&#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</p>
<p>（ 2 ）为对象添加方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(SomeClass.prototype, &#123;  </span><br><span class="line">    someMethod(arg1, arg2) &#123;  </span><br><span class="line">    ···  </span><br><span class="line">    &#125;,  </span><br><span class="line">    anotherMethod() &#123;  </span><br><span class="line">    ···  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">//  等同于下面的写法  </span><br><span class="line">SomeClass.prototype.someMethod = function (arg1, arg2) &#123;  </span><br><span class="line">···  </span><br><span class="line">&#125;;  </span><br><span class="line">SomeClass.prototype.anotherMethod = function () &#123;  </span><br><span class="line">···  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 assign 方法添加到 SomeClass.prototype 之中。<br>（ 3 ）克隆对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;  </span><br><span class="line">    return Object.assign(&#123;&#125;, origin);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。<br>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。<br>（ 4 ）合并多个对象<br>将多个对象合并到某个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const merge =(target, ...sources) =&gt; Object.assign(target, ...sources);  </span><br></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const merge =(...sources) =&gt; Object.assign(&#123;&#125;, ...sources);  </span><br></pre></td></tr></table></figure>

<p>（ 5 ）为属性指定默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;  </span><br><span class="line">    logLevel: 0,  </span><br><span class="line">    outputFormat: &#x27;html&#x27;  </span><br><span class="line">&#125;;  </span><br><span class="line">function processContent(options) &#123;  </span><br><span class="line">    let options = Object.assign(&#123;&#125;, DEFAULTS, options);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。<br>注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。</p>
<h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h2><blockquote>
<p>要指定函数的this指向哪个函数，可以用函数本身的apply()方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数就是Array，表示函数本身的参数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>

<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [3, 5, 4]); // 5</span><br><span class="line">Math.max.call(null, 3, 5, 4); // 5</span><br></pre></td></tr></table></figure>

<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<p>call()方法是预定义的javascript方法，它可以用来调用所有者对象作为参数的方法，通过call()，可以使用属于另一个对象的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Gates&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;Steve&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Jobs&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1);  <span class="comment">// 将返回 &quot;Bill Gates&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>带参数的 call() 方法</strong></p>
<p>call() 方法可接受参数：</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName + <span class="string">&quot;,&quot;</span> + city + <span class="string">&quot;,&quot;</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Gates&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1, <span class="string">&quot;Seattle&quot;</span>, <span class="string">&quot;USA&quot;</span>);<span class="comment">//Bill Gates,Seattle,USA</span></span><br></pre></td></tr></table></figure>



<p>apply()方法与call()方法非常相似，它们之间的区别有：</p>
<ul>
<li>call()方法分贝接收参数</li>
<li>apply()方法接收数组形式的参数</li>
<li>如果使用数组而不是参数列表，则apply()方法非常方便</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName + <span class="string">&quot;,&quot;</span> + city + <span class="string">&quot;,&quot;</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1, [<span class="string">&quot;Oslo&quot;</span>, <span class="string">&quot;Norway&quot;</span>]);</span><br></pre></td></tr></table></figure>



<h2 id="如何理解面向对象"><a href="#如何理解面向对象" class="headerlink" title="如何理解面向对象"></a>如何理解面向对象</h2><p><strong>面向对象是一个编程思想，支撑面向对象编程思想的语法是类和对象，构造函数充当类的角色。</strong></p>
<p>继承：侧重是从父一级构造函数，ji’cheng’doa’de属性和方法</p>
<p>多态：侧重是子一级自己重写和新增的属性和方法。</p>
<h2 id="proto-和prototype"><a href="#proto-和prototype" class="headerlink" title="__proto__和prototype"></a><code>__proto__</code>和<code>prototype</code></h2><ul>
<li>构造函数构造出来的对象，有一个属性<code>__proto__</code>,指向构造函数这个对象的构造函数的原型。</li>
<li></li>
</ul>
<h2 id="五种继承方式"><a href="#五种继承方式" class="headerlink" title="五种继承方式"></a>五种继承方式</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><ul>
<li><p>核心：将父类实例作为子类原型</p>
</li>
<li><p>优点：方法复用</p>
<ul>
<li>由于方法定义在父类的原型上，复用了父类构造函数的方法，比如say()方法</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>创建子类实例的时候，不能传父类的参数</li>
<li>子类实例共享了父类构造函数的引用属性，比如arr属性</li>
<li>无法实现多继承</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.name=name||<span class="string">&#x27;父亲&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.arr=[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">like</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.like=like;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Child.prototype=<span class="keyword">new</span> Parent();<span class="comment">//核心，但此时的child.prototype.constructor==Parent</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Child.prototype.constructor=Child;<span class="comment">//修正constructor的指向，让它重新指向Child</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> boy1=<span class="keyword">new</span> Child();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> boy2=<span class="keyword">new</span> Child();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//console.log(boy1.say);</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.say(),boy2.say(),boy1.say===boy2.say);<span class="comment">//hello hello true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//优点：共享了父类构造函数的say方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//console.log(boy1.say(),boy2.say(),boy1.say==boy2.say);</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//缺点：不能向父类构造函数传参</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.name,boy2.name,boy2.name==boy1.name);<span class="comment">//父亲，父亲，true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//缺点：子类实例共享了父类构造函数的引用属性，比如arr属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			boy1.arr.push(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//修改了boy1的arr属性，boy2的arr属性也会变化，因为两个实例的原型上（Child.prototype）有了父类构造函数的实例属性arr；</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy2.arr);<span class="comment">//[1,2]</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			注意1：修改boy1的name属性，是不会影响到boy2.name的，因为设置boy1.那么相当于在子类实例中新增了name属性。</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			注意2: </span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			console.log(boy1.constructor);//你会发现实例的构造函数居然是Parent</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			而实际上，我们希望子类实例的构造函数是Child，所以要记得修改构造函数指向。</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml">			*/</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure>

<h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h3><ul>
<li><p>核心：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p>
</li>
<li><p>优点：实例之间独立</p>
<ul>
<li>创建子类实例，可以向父类构造函数传参数</li>
<li>子类实例不共享父类构造函数的引用属性，如arr属性</li>
<li>可实现多继承（通过多个call或apply继承多个父类）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>父类的方法不能复用</li>
</ul>
<p>由于方法在父构造函数中定义，导致方法不能复用（因为每次创建子类实例都要创建一遍方法），比如say方法。（方法应该要复用，共享）</p>
<ul>
<li>子类实例，继承不了父类原型上的属性（因为没有用到原型）</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.name=name;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.arr=[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">				</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				Parent.call(<span class="built_in">this</span>,name);</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.like=like;</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy1=<span class="keyword">new</span> Child(<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;orange&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy2=<span class="keyword">new</span> Child(<span class="string">&#x27;小亮&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点：可向父类构造函数传递参数</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.name,boy2.name)<span class="comment">//小明，小亮</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点：不共享父类构造函数的引用属性</span></span></span><br><span class="line"><span class="javascript">			boy1.arr.push(<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.arr,boy2.arr);<span class="comment">//[1,2]  [1]</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//缺点：方法不能复用</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.say==boy2.say);<span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//缺点：不能继承父类原型上的方法</span></span></span><br><span class="line"><span class="javascript">			boy1.say();<span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><ul>
<li><p>核心：通过调用父类构造函数，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
</li>
<li><p>优点</p>
<ul>
<li>保留构造函数的优点:创建子类实例，可以向父类构造函数传承诺书</li>
<li>保留原型链的优点：父类的方法定义在父类的原型对象上，可以实现方法复用</li>
<li>不共享父类的引用属性，比如arr属性</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>由于调用了2次父类的构造方法，会存在一份多余的父类实例属性。</p>
<p>原因：第一次Parent.call(this),从父类拷贝一份父类实例实例属性作为子类的实例属性，第二次Child.prototype=new Parent();创建父类实例作为子类原型，Child.prototype=new Parent();创建父类实例作为子类原型，Child.prototype中的父类属性和方法会被第一次拷贝的实例属性屏蔽掉，所以多余。</p>
</li>
</ul>
</li>
<li><p>注意：</p>
<p>组合继承这种方式，要记得修改Child.prototype.constructor指向</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">12.5rem</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#00BFFF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.name=name;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.arr=[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">				</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				Parent.call(<span class="built_in">this</span>,name);</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.like=like;</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			Child.prototype=<span class="keyword">new</span> Parent();</span></span><br><span class="line"><span class="javascript">			Child.prototype.constructor=Child;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(Child.prototype.__proto__==Parent.prototype);<span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy1=<span class="keyword">new</span> Child(<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;orange&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy2=<span class="keyword">new</span> Child(<span class="string">&#x27;小亮&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点1：可以向父类构造函数传参数</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.name,boy1.like);<span class="comment">//小明，orange</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点2：可复用父类原型上的方法</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.say());<span class="comment">//hello</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点3：不共享父类的引用属性，如arr属性</span></span></span><br><span class="line"><span class="javascript">			boy1.arr.push(<span class="number">3</span>);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.arr,boy2.arr);[<span class="number">1</span>,<span class="number">3</span>]  [<span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//缺点：由于调用了2次父类的构造方法，会存在一份多余的父类实例属性</span></span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-组合继承优化1"><a href="#4-组合继承优化1" class="headerlink" title="4.组合继承优化1"></a>4.组合继承优化1</h3></li>
<li><p>核心</p>
<p>通过这种方法，砍掉父类的实例属性，这样在调用父类的构造函数的时候，就不会初始化两次实例，避免组合继承的缺点</p>
</li>
<li><p>优点</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>保留构造函数的优点：创建子类实例，可以向父类构造函数传参</li>
<li>保留原型链的优点：父类的实例方法定义在父类的原型对象上，可以实现方法复用。</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><p>修正构造函数的指向之后，父类实例的构造函数指向，同时也发生变化（这是我们不希望的）</p>
</li>
<li><p>注意</p>
<ul>
<li><p>记得修复Child.prototype.constructor指向</p>
<p>原因是：不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">12.5rem</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#00BFFF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.name=name;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.arr=[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">				</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				Parent.call(<span class="built_in">this</span>,name);</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.like=like;</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">			Child.prototype=Parent.prototype;<span class="comment">//核心</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(Child.prototype.__proto__==Parent.prototype);<span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy1=<span class="keyword">new</span> Child(<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;orange&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> boy2=<span class="keyword">new</span> Child(<span class="string">&#x27;小亮&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> p=<span class="keyword">new</span> Parent(<span class="string">&#x27;父亲&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点1：可以向父类构造函数传参数</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.name,boy1.like);<span class="comment">//小明，orange</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点2：可复用父类原型上的方法</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.say());<span class="comment">//hello</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//优点3：不共享父类的引用属性，如arr属性</span></span></span><br><span class="line"><span class="javascript">			boy1.arr.push(<span class="number">3</span>);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.arr,boy2.arr);[<span class="number">1</span>,<span class="number">3</span>]  [<span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">			<span class="comment">//缺点：当修复子类构造函数的指向后，父类实例的构造函数指向也会跟着改变</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//修复前</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.constructor)<span class="comment">//Parent</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//修复后</span></span></span><br><span class="line"><span class="javascript">			Child.prototype.constructor=Child;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(boy1.constructor);<span class="comment">//Child</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">//存在的问题</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(p.constructor)<span class="comment">//Child</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">			具体原因：</span></span></span><br><span class="line"><span class="comment"><span class="javascript">				因为是通过原型来实现继承的，Child.prototype的上面是没有constructor属性的，就会往上找，</span></span></span><br><span class="line"><span class="comment"><span class="javascript">				这样就找到了Parent.prototype上面的structor属性，当修改了子类实力的constructor属性，所有的constructor的指向都会发生变化。</span></span></span><br><span class="line"><span class="comment"><span class="javascript">				</span></span></span><br><span class="line"><span class="comment"><span class="javascript">			*/</span></span></span><br><span class="line"><span class="javascript">			</span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-组合继承优化2-又称寄生组合继承–完美方式"><a href="#5-组合继承优化2-又称寄生组合继承–完美方式" class="headerlink" title="5.组合继承优化2 又称寄生组合继承–完美方式"></a>5.组合继承优化2 又称寄生组合继承–完美方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">			<span class="selector-class">.box</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">				<span class="attribute">height</span>: <span class="number">12.5rem</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">				<span class="attribute">background-color</span>: <span class="number">#00BFFF</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.name=name;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.arr=[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				Parent.call(<span class="built_in">this</span>,name);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">this</span>.like=like;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//通过创建中间对象，子类原型和父类原型就会隔离开，不是同一个，有效避免了方法四的缺点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Child.prototype=<span class="built_in">Object</span>.create(Parent.prototype);<span class="comment">//核心</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//修复构造函数的指向</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Child.prototype.constructor=Child;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> boy1=<span class="keyword">new</span> Child(<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;orange&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> boy2=<span class="keyword">new</span> Child(<span class="string">&#x27;小亮&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> p=<span class="keyword">new</span> Parent(<span class="string">&#x27;父亲&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//优点1：可以向父类构造函数传参数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.name,boy1.like);<span class="comment">//小明，orange</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//优点2：可复用父类原型上的方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			boy1.say();<span class="comment">//hello</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//优点3：不共享父类的引用属性，如arr属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			boy1.arr.push(<span class="number">3</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.arr,boy2.arr);[<span class="number">1</span>,<span class="number">3</span>]  [<span class="number">1</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//修复前</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.constructor)<span class="comment">//Parent</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//修复后</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			Child.prototype.constructor=Child;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(boy1.constructor);<span class="comment">//Child</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//存在的问题解决</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(p.constructor)<span class="comment">//Parent</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure>

<h3 id="6-单个方法的继承"><a href="#6-单个方法的继承" class="headerlink" title="6. 单个方法的继承"></a>6. 单个方法的继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类B的print方法先调用父类A的print方法，再部署自己的代码，这就等于继承了父类A的print方法。</p>
<h3 id="7-多重继承"><a href="#7-多重继承" class="headerlink" title="7.多重继承"></a>7.多重继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.world = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="built_in">this</span>);</span><br><span class="line">  M2.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.world <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul>
<li>在引用数据类型中，变量名保存在栈内存中，值保存在堆内存中，但是栈内存会提供一个引用的地址执行堆内存中的值。</li>
</ul>
<p><img src="C:\Users\z1016\AppData\Roaming\Typora\typora-user-images\image-20210306090130269.png" alt="image-20210306090130269"></p>
<p><img src="C:\Users\z1016\AppData\Roaming\Typora\typora-user-images\image-20210306090225190.png" alt="image-20210306090225190"></p>
<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>问题：只能拷贝数据，如果被拷贝的对象中有方法则无法拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data))</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数的三种调用方式"><a href="#匿名函数的三种调用方式" class="headerlink" title="匿名函数的三种调用方式"></a>匿名函数的三种调用方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①先用()包起来,然后再后面跟 (参数) </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//②先后面跟(参数),然后再()包起来</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;(<span class="string">&quot;333&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//③正常函数格式，前面加 !</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;(<span class="string">&quot;444&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="this指向的理解"><a href="#this指向的理解" class="headerlink" title="this指向的理解"></a>this指向的理解</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar) &#125;,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = obj.foo;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// 1</span></span><br><span class="line">foo() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>obj变量指向的是一个对象，JavaScript引擎会先在内存中生成一个对象,然后将对象的内存地址赋值给obj这个变量，也就是说obj是一个地址。</p>
<p>如果对象中保存的是一个函数，引擎会将函数单独保存在内存中，然后将函数的地址赋值给foo属性的value属性。</p>
<p><img src="C:\Users\z1016\AppData\Roaming\Typora\typora-user-images\image-20210307145459698.png" alt="image-20210307145459698"></p>
<p>因为函数是一个单独的值，所以它可以在不同的环境执行。</p>
<p>而this的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">f</span>: f,</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数f在全局环境执行，this.x指向全局环境的x</p>
<p><img src="C:\Users\z1016\AppData\Roaming\Typora\typora-user-images\image-20210307145837251.png" alt="image-20210307145837251"></p>
<p>在obj环境执行，this.x指向obj.x</p>
<p>回到开头的问题，<code>obj.foo()</code>是通过<code>obj</code>找到<code>foo</code>，所以就是在<code>obj</code>环境执行。一旦<code>var foo = obj.foo</code>，变量<code>foo</code>就直接指向函数本身，所以<code>foo()</code>就变成在全局环境执行。</p>
<h2 id="上下文环境"><a href="#上下文环境" class="headerlink" title="上下文环境"></a>上下文环境</h2><h3 id="全局代码的上下文环境数据内容"><a href="#全局代码的上下文环境数据内容" class="headerlink" title="全局代码的上下文环境数据内容"></a>全局代码的上下文环境数据内容</h3><table>
<thead>
<tr>
<th>普通变量（包括函数表达式），如： var a = 10;</th>
<th>声明（默认赋值为undefined）</th>
</tr>
</thead>
<tbody><tr>
<td>函数声明，如： function fn() { }</td>
<td>赋值</td>
</tr>
<tr>
<td>this</td>
<td>赋值</td>
</tr>
</tbody></table>
<h3 id="函数体的上下文环境数据内容"><a href="#函数体的上下文环境数据内容" class="headerlink" title="函数体的上下文环境数据内容"></a>函数体的上下文环境数据内容</h3><p>在以上数据的基础上附加的数据：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>赋值</th>
</tr>
</thead>
<tbody><tr>
<td>arguments</td>
<td>赋值</td>
</tr>
<tr>
<td>自由变量的取值作用域</td>
<td>赋值</td>
</tr>
</tbody></table>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>在执行全局代码之前，就产生一个执行上下文环境，每次调用函数都优惠产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。</p>
<p><img src="C:\Users\z1016\AppData\Roaming\Typora\typora-user-images\image-20210403103424391.png" alt="image-20210403103424391"></p>
<h2 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h2><p>在函数中this到底取何值，是在函数真正被调用执行的时候才确定的，函数定义的时候确定不了，因为this的取值是执行上下二五年环境的一部分，每次调用函数，都会产生一个新的执行上下文环境</p>
<h3 id="情况一：构造函数"><a href="#情况一：构造函数" class="headerlink" title="情况一：构造函数"></a>情况一：构造函数</h3><p>如果函数作为构造函数使用，那么其中的this就代表它即将new出来的对象</p>
<h3 id="情况二：函数作为对象的一个属性"><a href="#情况二：函数作为对象的一个属性" class="headerlink" title="情况二：函数作为对象的一个属性"></a>情况二：函数作为对象的一个属性</h3><p>如果函数作为对象的一个属性，并且作为对象的一个属性被调用时，函数中的this指向该对象。</p>
<h3 id="情况三：函数使用call或apply调用"><a href="#情况三：函数使用call或apply调用" class="headerlink" title="情况三：函数使用call或apply调用"></a>情况三：函数使用call或apply调用</h3><p>当一个函数被call何apply调用时，this的值就取传入的对象的值。</p>
<h3 id="情况四：全局调用普通函数"><a href="#情况四：全局调用普通函数" class="headerlink" title="情况四：全局调用普通函数"></a>情况四：全局调用普通函数</h3><p>在全局环境下，this永远是window</p>
<p>普通函数在调用是，其中的this也都是window</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
